\chapter{隐私保护的链上链下协同计算模型}

为了满足去中心化计算的特质似乎存在一个潜在的要求，即智能合约的执行逻辑与输入输出数据对于所有节点来说都是透明的。而这一约束极大限制了存在数据隐私需求的应用实现去中心化特性。有助于解除这一约束的密码学工具是零知识证明技术。如前所述，研究人员已经提出了一些满足各种隐私定义与信任假设的系统。然而他们对系统的具现化实现与一些特定信任假设的强依赖从根本上就限制了模型的通用性，通常只能工作在特定场景中而不能满足各类应用的开发需求。对此，我们尝试通过本章解答这一问题：
\begin{center}
    \textbf{是否存在一个隐私保护的通用模型可以满足去中心化特性与可用性？}
\end{center}
\section{系统模型}
在本节我们将对系统中涉及的模块进行介绍与功能划分，这有助于我们后续对系统拆分进行单独建模并提供一个可组合的通用模型。
\subsection{基础结构}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-structure}系统结构图}
\end{figure}

如\autoref{fig:ch3-structure}所示，在隐私保护的链上链下协同计算系统中主要有三类角色：用户，链上节点与链下计算节点。特别地，我们将用户与链下计算节点进行区分定义，这是因为正如第一章提到的那样，在大量的应用场景中，隐私数据的所有方与使用方是分离的。用户和链下计算节点都关联了各自的隐私数据，用户可选地将数据作为交易内容暴露上链，链下计算节点通过零知识证明技术等链下计算方式隐藏隐私输入，将允许泄露的公开结果和计算证明暴露给链上节点。当然在一些应用场景下，链下计算节点也会作为交易的发起方(\autoref{fig:ch3-structure-b})，此时用户和链下计算节点的角色将重叠在一起。与前述两者不同，链上节点通过链上智能合约共同维护分布式账本的状态，对交易的验证与执行都是公开透明的。

尽管在隐私保护的系统模型中为了实现对数据与计算逻辑的保护，智能合约的行为变得更为复杂，然而其实质上每次智能合约的调用过程的都是一次账本状态由旧到新的变更。因此为了简化复杂合约行为与账本的交互，我们将协同计算模型中的智能合约建模为反应式状态机。用户通过提交交易的方式向智能合约发送一些固定语义的高级命令，例如转账或投票等。一旦分布式账本确认了这些交易，用户可以收到交易的附带回执或通过主动查询账本的方式来确认：交易是否成功被执行以及交易在智能合约逻辑中完成的对相关账本状态的更新情况。

值得一提的是在隐私保护下的智能合约可以被细化为两个部分，即链上合约与链下合约，分别部署在链上节点和链下计算节点中。链上合约维护了分布式账本上公共状态$\sigma$，而链下合约则分别维护链下节点的私有状态。对于链下节点$\mathit{p}$,对应的私有状态记为$\rho_\mathit{p}$。对于涉及只一方的交易，对应的智能合约状态可以描述为$(\sigma, \rho_\mathit{p})$。虽然诚实的链下计算节点，往往根据预先约定的合约行为更新自己的私有状态。但是合约设计者必须意识到链下节点的私有状态更新是不被默认信任的，不诚实节点可以随意更改他们的状态。对于必须依赖链下节点状态的合约行为，可以通过要求链下计算节点提供状态更新证明来补全信任，然而这也会增加交互代价和公共状态规模\cite{9505181}。

为了对隐私保护这一特性进行建模，我们需要指出在整个系统中，只有那些经过提前协商并固定在合约行为中的用户隐私是允许被泄露的。这样的泄露只发生在两种情况下：用户提交交易到分布式账本，链下计算中涉及的隐私输入。对此文献\cite{9505181}指出在用户交易广播之前可要求他们签署对隐私泄露的描述文件来获得限定隐私泄露的许可。显然针对交易体中泄露的隐私内容受限于链上合约的设计，其使用逻辑是公开透明的。而针对链下计算中使用的隐私输入，尽管我们无法披露计算的具体过程，但是对计算结果的验证和应用受限于链上的验证过程。通过固定链上的证明逻辑与协同计算间的语义信息，我们可以反过来约束在链下计算中泄露的隐私内容。综上，我们可以确保在这仅含这两种隐私泄露场景的协同计算系统中用户和链下计算节点能够实现对自己的隐私泄露情况的完全控制。
\subsection{功能定义}
我们将触发一次智能合约状态变更的全过程，即$(\sigma, \rho_\mathit{p})\rightarrow(\sigma', \rho_\mathit{p}')$，定义为一次链上链下协同计算。这一定义有助于我们简化一些复杂的合约行为，例如一笔交易执行过程中包含多方链下隐私计算，可以将其划分为多次链上链下协同计算来描述。关于这类问题，我们将在后续小节作详细介绍。

基于\autoref{fig:ch3-structure}构建的系统模型，我们可以简单描述出一次完整的隐私保护协同计算过程。如下所述，在一次协同计算过程中，每个步骤都是顺序执行的关系。其中涉及隐私保护的步骤为可选项，这是因为即使在一个存在隐私保护内容的智能合约中也可能包含部分逻辑不涉及链下计算节点的隐私泄露。

\begin{enumerate}
\setlength{\itemsep}{1pt}
\item 用户基于自身数据构建一笔交易内容，并提交给链上节点。
\item 链上节点在执行交易时将调用链上合约的相应逻辑，这一逻辑除 了链上的计算过程外还可能包括对链下计算的调用请求$\mathit{q}$。
\item （可选）调用请求$\mathit{q}$将被发送到链下计算节点$\mathit{p}$进行处理。
\item （可选）在链下计算节点中，基于调用请求与链下隐私数据，节点将完成计算并更新私有状态$\rho_\mathit{p}\rightarrow\rho_\mathit{p}'$，最后生成零知识证明。
\item （可选）链下计算节点返回计算结果与计算证明作为对调用请求的响应$\mathit{r}$。
\item （可选）链上节点验证返回内容的合法性。
\item 链上节点基于链上计算与链下计算结果完成链上状态变更$\sigma\rightarrow\sigma'$，返回必要交易回执。
\end{enumerate}

在本文中我们将忽略交易在共识中的处理过程，这一部分并不是我们讨论的重点。但需要注意的是，在并发处理多笔交易时，我们必须考虑交易的执行顺序。一组交易在不同的执行顺序下可能出现不同的状态更新结果。在后续的小节中，我们将对这些情况作深入分析。
\section{智能合约模型}
\subsection{状态转移}
\subsection{用户隐私泄露}

\subsection{链下隐私泄露}

\section{协同计算交易}

\subsection{交易分段提交}

trans组+checkpoint
\subsection{交易依赖性分析}

\section{面向链上链下协同计算的通用协议}
\subsection{基于KACHAIN的前置建模}
简单账本模型

零知识证明
\subsection{协议内涵}
\subsection{UC框架下的协议描述}

\section{安全性分析}

