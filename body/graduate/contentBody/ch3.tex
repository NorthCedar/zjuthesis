\chapter{隐私保护的链上链下协同计算模型}

为了满足去中心化计算的特质似乎存在一个潜在的要求，即智能合约的执行逻辑与输入输出数据对于所有节点来说都是透明的。而这一约束极大限制了存在数据隐私需求的应用实现去中心化特性。

有助于解除这一约束的密码学工具是零知识证明技术。如前所述，研究人员已经提出了一些满足各种隐私定义与信任假设的系统\cite{//}。然而这些工作并没有讨论到针对数据孤岛场景下的适用性。他们对系统的具现化实现和对特定信任的强依赖使得模型通常只能工作在特定场景中而不能满足各类应用的开发需求。对此，我们尝试通过本章解答这一问题：\textbf{在数据孤岛场景下是否存在一个满足去中心化特性的隐私保护通用模型？}
\section{系统架构}
在本节我们将对系统中涉及的模块进行介绍与功能划分，这有助于我们后续对系统拆分进行单独建模并组合为一个通用模型。
\subsection{基础结构}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-structure}系统结构图}
\end{figure}

\paragraph{系统角色}如\autoref{fig:ch3-structure}所示，在隐私保护的链上链下协同计算系统中主要有三类角色：用户，链上节点与链下计算节点。特别地，我们将用户与链下计算节点进行区分定义，这是因为正如第一章提到的那样，在大量的应用场景中，隐私数据的所有方与使用方是分离的。用户和链下计算节点都关联了各自的隐私数据，用户可选地将数据作为交易内容暴露上链，链下计算节点通过零知识证明技术等链下计算方式隐藏隐私输入，将允许泄露的公开结果和计算证明暴露给链上节点。当然在一些应用场景下，链下计算节点也会作为交易的发起方(\autoref{fig:ch3-structure-b})，此时用户和链下计算节点的角色将重叠在一起。与前述两者不同，链上节点通过链上智能合约共同维护分布式账本的状态，对交易的验证与执行都是公开透明的。

\paragraph{合约状态}尽管在隐私保护的系统模型中为了实现对数据与计算逻辑的保护，智能合约的行为变得更为复杂，然而其实质上每次智能合约的调用过程的都是一次账本状态由旧到新的变更。因此为了简化复杂合约行为与账本的交互，我们将协同计算模型中的智能合约建模为复制状态机。用户通过提交交易的方式向智能合约发送一些固定语义的高级命令，例如转账或投票等。一旦分布式账本确认了这些交易，用户可以收到交易的附带回执或通过主动查询账本的方式来确认：交易是否成功被执行以及交易在智能合约逻辑中完成的对相关账本状态的更新情况。

值得一提的是在通用的协同计算模型下的智能合约可以被细化为两个部分，即链上合约与链下合约，分别维护了分布式账本上公共状态$\sigma$和链下节点的私有状态。对于链下节点$\mathit{p}$,对应的私有状态记为$\rho_\mathit{p}$。对于涉及只一方的交易，对应的智能合约状态可以描述为$(\sigma, \rho_\mathit{p})$。

虽然诚实的链下计算节点，往往根据预先约定的合约行为更新自己的私有状态。但是合约设计者必须意识到链下节点的私有状态更新是不被默认信任的，不诚实节点可以随意更改他们的状态。对于必须依赖链下节点状态的合约行为，可以通过要求链下计算节点提供状态更新证明从而将链下状态的管理纳入链上合约中，然而这也会增加交互代价和公共状态规模\cite{9505181}。

\paragraph{隐私保护}为了对隐私保护这一特性进行建模，我们需要指出在整个系统中，只有那些经过提前协商并固定在合约行为中的用户隐私是允许被泄露的。这样的泄露只发生在两种情况下：用户提交交易到分布式账本，链下计算中涉及的隐私输入。对此文献\cite{9505181}指出在用户交易广播之前可要求他们签署对隐私泄露的描述文件来获得限定隐私泄露的许可。显然针对交易体中泄露的隐私内容受限于链上合约的设计，其使用逻辑是公开透明的。而针对链下计算中使用的隐私输入，尽管我们无法披露计算的具体过程，但是对计算结果的验证和应用始终受限于链上的验证过程。通过固定链上的证明逻辑与协同计算间的语义信息，我们可以反过来约束在链下计算中泄露的隐私内容。综上，我们可以确保在仅含这两种隐私泄露场景的协同计算系统中，用户和链下计算节点能够实现对自己的隐私泄露情况的完全控制。
\subsection{功能定义}
我们将触发一次智能合约状态变更的全过程，即$(\sigma, \rho_\mathit{p})\rightarrow(\sigma', \rho_\mathit{p}')$，定义为协同计算中的一个中间段。则对于一次涉及$n$次状态变更的完整的协同计算$(\sigma, \rho)\rightarrow(\sigma^n, \rho_{p_0,\dots,p_n})$可以拆分为$(\sigma, \rho)\rightarrow(\sigma^0, \rho_{p_0})\rightarrow(\sigma^1, \rho_{p_0,p_1})\rightarrow \dots \rightarrow (\sigma^n, \rho_{p_0,\dots,p_n})$。这一定义有助于我们简化一些复杂的合约行为，例如一笔交易引发的链上链下协同计算执行过程中包含多方链下隐私计算。关于这类问题，我们将在后续小节作详细介绍。

基于\autoref{fig:ch3-structure}构建的系统模型，我们可以简单描述出一次完整的隐私保护协同计算过程。如下所述，在一次协同计算过程中，每个步骤都是顺序执行的关系。其中涉及隐私保护的步骤为可选项，这是因为即使在一个存在隐私保护内容的智能合约中也可能包含部分逻辑不涉及链下计算节点的隐私泄露。

\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
\item 用户基于自身数据构建一笔交易内容，并提交给链上节点。
\item 链上节点在执行交易时将调用链上合约的相应逻辑，这一逻辑除 了链上的计算过程外还可能包括对链下计算的调用请求$\mathit{q}$。
\item （可选）调用请求$\mathit{q}$将被发送到链下计算节点$\mathit{p}$进行处理。
\item （可选）在链下计算节点中，基于调用请求与链下隐私数据，节点将完成计算并更新本地私有状态$\rho_\mathit{p}\rightarrow\rho_\mathit{p}'$，最后生成零知识证明。
\item （可选）链下计算节点返回计算结果与计算证明作为对调用请求的响应$\mathit{r}$。
\item （可选）链上节点验证返回内容的合法性。
\item 链上节点基于链上计算与链下计算结果完成链上状态变更$(\sigma, \rho)\rightarrow(\sigma', \rho')$，返回必要交易回执。
\end{enumerate}

在本文中我们将忽略交易在共识中的处理过程，这一部分并不是我们讨论的重点。但需要注意的是，在并发处理多笔交易时，我们必须考虑交易的执行顺序。一组交易在不同的执行顺序下可能出现不同的状态更新结果。在后续的小节中，我们将对这些情况作深入分析。
\section{协同计算下的智能合约模型}
智能合约通常被描述并实现为复制状态机，传递给状态机的输入一般从记录在账本上的交易中获取。为了描述隐私保护的智能合约模型，我们需要对这一定义作调整。这是因为如果所有输入都来自分布式账本上的交易，该模型中的所有数据都是公开可见的。

此处我们仍将隐私保护的智能合约抽象为复制状态机，将传递的输入替换为账本上记录的标识符，智能合约可以跟踪并验证这些标识符对应的输入信息。本节我们对基于复制状态机的智能合约模型进一步细化讨论，通过状态转移函数$\Gamma$来描述智能合约状态的变化，并构建隐私泄露函数$lkg_\sigma, lkg_\rho$用于分析在跟踪验证标识符对应输入的过程中发生的数据泄露。
\subsection{智能合约状态转移}
如\autoref{fig:ch3-transfer}所示，基于隐私保护的智能合约状态应包含两部分：链上与链下。基于这一背景，本节中我们先分别提出链上与链下部分的状态交互模型，再给出系统状态转移函数，最后组合为隐私保护的链上链下协同计算状态转移模型。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-transfer}智能合约状态转移图}
\end{figure}

定义链下计算$\mathcal{O}_{\alpha}$为一个维护状态$\alpha$的交互式模块，假设$\alpha$初始状态为$\alpha^o$，当前的上下文为$z$，向量$\vec{\alpha}$按执行顺序依次记录每次附带输入$w$的请求执行后的状态。那么$\mathcal{O}_{\alpha}$允许的交互如下：

\begin{breakablealgorithm}
    \caption{链下计算$\mathcal{O}_{\alpha}$}
    \label{alg:ch3-1}
    \begin{algorithmic} 
    \item [收到请求$q(w)$]:
    \IF {$\alpha = \perp$} 
    \STATE return $\perp$
    \ENDIF
    \STATE 计算$(\alpha', r) \leftarrow compute(q, w, z, \alpha)$
    \STATE $\alpha \leftarrow \alpha'$
    \STATE return $r$
    \item [收到请求$apply$]:
    \STATE $\vec{\alpha} \leftarrow \vec{\alpha} \parallel \alpha$
    \item [收到请求$check$]:
    \STATE return $(\vec{\alpha}, \alpha)$
    \end{algorithmic}
\end{breakablealgorithm}

链上计算与链下类似，但是输入变为用户创建的交易$\tau$。需要注意的是在链上与链下交互模型中虽然都存在上下文$z$，但是两者的具体内容并不相同，例如为了提供隐私保护，链下计算的上下文中会包含随机因子$\eta$。后续我们将具体讨论$z$中的内容。以下我们给出链上计算$\mathcal{O}_{\alpha}$允许的交互：

\begin{breakablealgorithm}
    \caption{链上计算$\mathcal{O}_{\alpha}$}
    \label{alg:ch3-2}
    \begin{algorithmic} 
        \setlength{\itemsep}{0pt}
        \setlength{\parsep}{0pt}
        \setlength{\parskip}{0pt}
        \item [收到请求$q(\tau)$]:
        \IF {$\alpha = \perp$}
        \STATE return $\perp$
        \ENDIF
        \STATE 计算$(\alpha', r) \leftarrow compute(\tau, z, \alpha)$
        \STATE $\alpha \leftarrow \alpha'$
        \STATE return $r$
        \item [收到请求$apply$]:
        \STATE $\vec{\alpha} \leftarrow \vec{\alpha} \parallel \alpha$
        \item [收到请求$check$]:
        \STATE return $(\vec{\alpha}, \alpha)$
    \end{algorithmic}
\end{breakablealgorithm}

与KACHAIN\cite{9505181}类似，我们使用状态转移函数来描述合约状态变更过程。设合约初始状态为$\varnothing$，在确定输入时，状态转移函数将给出固定的输出和对应的新状态。尽管为了隐私保护模型可能会引入随机流，但是这并不会影响状态转移函数的确定性。这是因为对于智能合约模型，一笔交易被创建后，其所需的随机参数都应被固定在内容中。

对此，我们给出系统状态转移函数$\Gamma$的声明，即$\Gamma:(\varnothing', y) \leftarrow f(\varnothing, p, z, w,\tau)$。其中，$\varnothing$表示初始状态；$\varnothing'$表示合约执行后的新状态；$p$为链下计算方；$z$表示执行过程中的系统上下文；$\tau$表示造成状态转移的交易；$w$为链下计算中的输入。可以知道$\Gamma$实际可以由两部分构成：$\Gamma: (\Gamma_{\mathcal{O}_\sigma}, \Gamma_{\mathcal{O}_\rho})$。基于维护状态$\alpha$的交互式模块的状态转移函数$\Gamma_{\mathcal{O}_\alpha}$，其执行流程如下：

\begin{breakablealgorithm}
    \caption{状态转移函数$\Gamma_{\mathcal{O}_\alpha}$}
    \label{alg:ch3-3}
    \begin{algorithmic} 
        \item[给定输入]:$q$
        \STATE let $y \leftarrow \perp, \mathcal{T} \leftarrow \epsilon$
        \STATE send $q$ to $\mathcal{O}_\alpha$, receive $r$
        \STATE let $y \leftarrow r, \mathcal{T} \leftarrow \mathcal{T} \parallel (q, r)$
        \STATE send $check$ to $\mathcal{O}_\alpha$, receive $(\vec{\alpha}, \alpha)$
        \IF {$\alpha = \perp \vee y = \perp$}
        \STATE return $(\alpha, \mathcal{T}, y)$
        \ENDIF
        \STATE send $apply$ to $\mathcal{O}_\alpha$
        \STATE let $\mathcal{T} \leftarrow \mathcal{T} \parallel (apply, \cdot)$
        \STATE return $(\alpha, \mathcal{T}, y)$
    \end{algorithmic}
\end{breakablealgorithm}

最后根据上述定义和功能分析，我们给出基于隐私保护的链上链下协同计算模型的状态转移流程如下所示。在后续的算法中，我们将$\Gamma(\sigma, \rho[p], p, w, z, \cdot, \tau)$简写为$\Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(\tau)$，其中$\mathcal{O}_\sigma \leftarrow \mathcal{O}(\sigma, z), \mathcal{O}_\rho \leftarrow \mathcal{O}(\rho[p], p, w, z)$。

\begin{breakablealgorithm}
    \caption{协同计算下的状态转移流程}
    \label{alg:ch3-4}
    \begin{algorithmic} 
        \item [给定输入]:$(\sigma, \rho), p, w, a, z, \tau$
        \STATE let $(\sigma_{new}, \rho[p]_{new},\mathcal{T}_\sigma, \mathcal{T}_\rho, y') \leftarrow \Gamma(\sigma, \rho[p], p, w, z, a, \tau)$
        \STATE let $y \leftarrow \perp$
        \STATE let $\sigma \leftarrow \sigma_{new}, \rho[p] \leftarrow \rho[p]_{new}, y \leftarrow y'$
        \STATE return $(\sigma, \rho), \mathcal{T}_\sigma, \mathcal{T}_\rho, y$
    \end{algorithmic}
\end{breakablealgorithm}

\subsection{用户交易隐私泄露}
隐私泄露与状态转移的分离性是基于智能合约的执行逻辑造成的，当一笔交易被创建并提交后，其泄露的隐私数据已被固定，而后才通过智能合约的执行完成状态转移。因此我们可以对交互过程中隐私数据泄露进行独立建模，从而保证模型是具备隐私保护性质的。如前所述，交互中可能存在的输入点有两个，用户构建交易与链下计算节点计算时使用的输入。

对于用户创建交易造成的隐私泄露较为直观，因为交易一旦提交至链上账本都将公开可见，因此泄露的数据即为交易中的具体内容。自然地，我们给出用户交易隐私泄露函数${lkg}_\sigma$的定义：$(desc, D, z) \leftarrow f(u, v, \tau)$。其中，$u$为交易创建方，$v$为$u$对应的智能合约视图，$\tau$为预期创建的交易，$desc$提供了对需要泄露的隐私数据精确描述，$z$表示一些可能需要的上下文信息，$D$则是对应交易在账本上所依赖的相关交易的记录集合。

基于之前所述的系统架构，交易创建方$u$所指代的可能为用户也可能为链下计算节点。交易创建方$u$对应的智能合约视图$v$应该包含与$u$相关的账本信息，即账本中的智能合约相关状态$\sigma$，$u$所能看见的账本长度，账本上未确认的交易集合$U$。$desc$是函数返回中极为重要的一项，这是用户对自身泄露隐私情况的了解方式。当交易创建者根据$desc$意识到发起交易泄露的隐私数据不符合预期时，可以取消创建交易避免隐私的意外泄露。因此隐私泄露函数作为隐私保护的必要前提在安全性分析中不应该存在被恶意修改的可能或用于对手的模拟。
\subsection{链下计算隐私泄露}
基于NIZK的链下计算通过构建证明的方式在隐藏了隐私输入的同时提供对链下的验证，然而对于验证时所需的公共输入或交互中附加的数据仍会被暴露出来。需要再次强调的是此处对泄露的定义是指约束在合约上的可预见的数据泄露，是节点允许透露的信息。通过对约定泄露和未预期的数据泄露进行区分有助于后续验证模型的安全性和隐私保护能力。

进一步地，我们定义链下计算隐私泄露函数，即${lkg}_\rho:(desc, D, z) \leftarrow f(p, v, w, transcript)$。与${lkg}_\sigma$的定义相类似，$v$为链下计算节点$p$的智能合约视图，$desc$提供了对需要泄露的隐私数据精确描述，$z$表示一些可能需要的上下文信息，$D$则是对应计算在链下账本上所依赖的相关计算的记录集合。此处还需要提供链下计算节点上部署的NIZK计算脚本$transcript$和链下计算输入$w$作为补充参数。

\section{协同计算下的隐私计算模型}
隐私计算主要负责完成链下计算并对链下计算过程生成NIZK证明以及提供NIZK验证，是隐私保护的协同计算过程中不可或缺的部分。虽然很多基于零知识证明技术的工作都包含了对隐私计算的实现设计，然而并没有工作基于协同计算对其进行系统化建模。在本节中，我们希望通过构建隐私计算模型，完成以下目标：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 定义隐私计算的具体功能
    \item 描述NIZK证明与验证流程，给出协同计算下账本状态$(\sigma, \rho)$更新的前提条件
\end{itemize}
\subsection{隐私计算功能概述}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-offchain}隐私计算交互流程}
\end{figure}
由外部请求触发的一次完整的执行流程为:根据收到的链下计算请求$q_\rho$选择链下计算脚本为$transcript$完成计算从而更新链下私有状态，并对更新和计算过程生成证明$\pi$提交到链上，最后在验证成功后账本状态才被允许更改，最后达到链上与链下状态的一致性。

总体来看，隐私计算包括计算、证明和验证三个主要功能。除此以外，针对每个计算脚本都需要作初始化，其目的是1）为了将NP问题转化为可用于证明的约束系统，如R1CS，2）构建基于公共字符串假设的证明验证密钥对。具体来说，针对对应约束信息为$constraints_q$的链下计算问题$q$，隐私计算模块都将构建对应的计算，证明和验证上下文。计算上下文为$q$的计算脚本$transcript_q$，证明上下文包含证明密钥$pk_q$，而验证上下文则为验证密钥$vk_q$。

\subsection{NIZK证明与验证}
在协同计算中的链下计算过程并不可信，因此我们需要对链下计算生成证明，在验证其合法性后才可以将应用链下状态。因此我们可以定义NIZK的证明目标为：如\autoref{fig:ch3-offchain}所示，链下计算节点收到链下计算请求$q_\rho$后，链下计算节点将基于输入$w$执行对应计算脚本$transcript_{q_\rho}$，其对应的状态变更步骤集合为$\mathcal{T}_\sigma, \mathcal{T}_\rho$。当NIZK证明成立且执行时的状态不为$\perp$时，才能将$\mathcal{T}_\sigma, \mathcal{T}_\rho$应用到账本中。

对此我们指出在协同计算中NIZK证明的陈述$\mathcal{L}$可以描述为：对于$\sigma \neq \perp, \rho \neq \perp, \mathcal{O}_\sigma \leftarrow \mathcal{O}(\sigma, z), \mathcal{O}_\rho \leftarrow \mathcal{O}(\rho[p], p, w, z), q_\rho \Rightarrow \tau_\rho, (\cdot, \mathcal{T}_\sigma, \mathcal{T}_\rho, \cdot) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(\tau_\rho)$，则$(q_\rho, (w, \mathcal{T}_\rho)) \in \mathcal{L}$。协同计算中创建NIZK证明与验证的过程如下所示，我们用$\Pi$指代已创建的公开输入与证明的配对关系。其中choose方法是对具体NIZK计算的模拟并包含上一节中指出的上下文。

\begin{breakablealgorithm}
    \caption{协同计算中的证明验证流程}
    \label{alg:ch3-5}
    \begin{algorithmic} 
        \item [收到证明请求]: $Prove(x, witness)$
        \IF {$(x, witness) \notin \mathcal{L}$}
        \STATE return $\perp$
        \ENDIF
        \REPEAT
        \STATE choose $\pi$
        \UNTIL {$\pi \neq \perp \wedge (\cdot, \pi) \notin \Pi$}
        \STATE $\Pi \leftarrow \Pi \cup \{(x, \pi)\}$
        \STATE return $\pi$
        
        \item [收到验证请求]: $Verify(x, \pi)$
        \STATE return $(x, \pi) \in \Pi$
    \end{algorithmic}
\end{breakablealgorithm}