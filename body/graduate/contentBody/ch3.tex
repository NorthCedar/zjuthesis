\chapter{隐私保护的链上链下协同计算模型}

为了满足去中心化计算的特质似乎存在一个潜在的要求，即智能合约的执行逻辑与输入输出数据对于所有节点来说都是透明的。而这一约束极大限制了存在数据隐私需求的应用实现去中心化特性。有助于解除这一约束的密码学工具是零知识证明技术。如前所述，研究人员已经提出了一些满足各种隐私定义与信任假设的系统。然而他们对系统的具现化实现与一些特定信任假设的强依赖从根本上就限制了模型的通用性，通常只能工作在特定场景中而不能满足各类应用的开发需求。对此，我们尝试通过本章解答这一问题：
\begin{center}
    \textbf{是否存在一个隐私保护的通用模型可以满足去中心化特性与可用性？}
\end{center}
\section{系统模型}
在本节我们将对系统中涉及的模块进行介绍与功能划分，这有助于我们后续对系统拆分进行单独建模并提供一个可组合的通用模型。
\subsection{基础结构}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-structure}系统结构图}
\end{figure}

如\autoref{fig:ch3-structure}所示，在隐私保护的链上链下协同计算系统中主要有三类角色：用户，链上节点与链下计算节点。特别地，我们将用户与链下计算节点进行区分定义，这是因为正如第一章提到的那样，在大量的应用场景中，隐私数据的所有方与使用方是分离的。用户和链下计算节点都关联了各自的隐私数据，用户可选地将数据作为交易内容暴露上链，链下计算节点通过零知识证明技术等链下计算方式隐藏隐私输入，将允许泄露的公开结果和计算证明暴露给链上节点。当然在一些应用场景下，链下计算节点也会作为交易的发起方(\autoref{fig:ch3-structure-b})，此时用户和链下计算节点的角色将重叠在一起。与前述两者不同，链上节点通过链上智能合约共同维护分布式账本的状态，对交易的验证与执行都是公开透明的。

尽管在隐私保护的系统模型中为了实现对数据与计算逻辑的保护，智能合约的行为变得更为复杂，然而其实质上每次智能合约的调用过程的都是一次账本状态由旧到新的变更。因此为了简化复杂合约行为与账本的交互，我们将协同计算模型中的智能合约建模为复制状态机。用户通过提交交易的方式向智能合约发送一些固定语义的高级命令，例如转账或投票等。一旦分布式账本确认了这些交易，用户可以收到交易的附带回执或通过主动查询账本的方式来确认：交易是否成功被执行以及交易在智能合约逻辑中完成的对相关账本状态的更新情况。

值得一提的是在隐私保护下的智能合约可以被细化为两个部分，即链上合约与链下合约，分别部署在链上节点和链下计算节点中。链上合约维护了分布式账本上公共状态$\sigma$，而链下合约则分别维护链下节点的私有状态。对于链下节点$\mathit{p}$,对应的私有状态记为$\rho_\mathit{p}$。对于涉及只一方的交易，对应的智能合约状态可以描述为$(\sigma, \rho_\mathit{p})$。虽然诚实的链下计算节点，往往根据预先约定的合约行为更新自己的私有状态。但是合约设计者必须意识到链下节点的私有状态更新是不被默认信任的，不诚实节点可以随意更改他们的状态。对于必须依赖链下节点状态的合约行为，可以通过要求链下计算节点提供状态更新证明来补全信任，然而这也会增加交互代价和公共状态规模\cite{9505181}。

为了对隐私保护这一特性进行建模，我们需要指出在整个系统中，只有那些经过提前协商并固定在合约行为中的用户隐私是允许被泄露的。这样的泄露只发生在两种情况下：用户提交交易到分布式账本，链下计算中涉及的隐私输入。对此文献\cite{9505181}指出在用户交易广播之前可要求他们签署对隐私泄露的描述文件来获得限定隐私泄露的许可。显然针对交易体中泄露的隐私内容受限于链上合约的设计，其使用逻辑是公开透明的。而针对链下计算中使用的隐私输入，尽管我们无法披露计算的具体过程，但是对计算结果的验证和应用受限于链上的验证过程。通过固定链上的证明逻辑与协同计算间的语义信息，我们可以反过来约束在链下计算中泄露的隐私内容。综上，我们可以确保在这仅含这两种隐私泄露场景的协同计算系统中用户和链下计算节点能够实现对自己的隐私泄露情况的完全控制。
\subsection{功能定义}
我们将触发一次智能合约状态变更的全过程，即$(\sigma, \rho_\mathit{p})\rightarrow(\sigma', \rho_\mathit{p}')$，定义为一次链上链下协同计算。这一定义有助于我们简化一些复杂的合约行为，例如一笔交易执行过程中包含多方链下隐私计算，可以将其划分为多次链上链下协同计算来描述。关于这类问题，我们将在后续小节作详细介绍。

基于\autoref{fig:ch3-structure}构建的系统模型，我们可以简单描述出一次完整的隐私保护协同计算过程。如下所述，在一次协同计算过程中，每个步骤都是顺序执行的关系。其中涉及隐私保护的步骤为可选项，这是因为即使在一个存在隐私保护内容的智能合约中也可能包含部分逻辑不涉及链下计算节点的隐私泄露。

\begin{enumerate}
\setlength{\itemsep}{1pt}
\item 用户基于自身数据构建一笔交易内容，并提交给链上节点。
\item 链上节点在执行交易时将调用链上合约的相应逻辑，这一逻辑除 了链上的计算过程外还可能包括对链下计算的调用请求$\mathit{q}$。
\item （可选）调用请求$\mathit{q}$将被发送到链下计算节点$\mathit{p}$进行处理。
\item （可选）在链下计算节点中，基于调用请求与链下隐私数据，节点将完成计算并更新私有状态$\rho_\mathit{p}\rightarrow\rho_\mathit{p}'$，最后生成零知识证明。
\item （可选）链下计算节点返回计算结果与计算证明作为对调用请求的响应$\mathit{r}$。
\item （可选）链上节点验证返回内容的合法性。
\item 链上节点基于链上计算与链下计算结果完成链上状态变更$\sigma\rightarrow\sigma'$，返回必要交易回执。
\end{enumerate}

在本文中我们将忽略交易在共识中的处理过程，这一部分并不是我们讨论的重点。但需要注意的是，在并发处理多笔交易时，我们必须考虑交易的执行顺序。一组交易在不同的执行顺序下可能出现不同的状态更新结果。在后续的小节中，我们将对这些情况作深入分析。
\section{智能合约模型}
智能合约通常被描述并实现为复制状态机，传递给状态机的输入一般从记录在账本上的交易中获取。为了描述隐私保护的智能合约模型，我们需要对这一定义作调整。这是因为如果所有输入都来自分布式账本上的交易，该模型中的所有数据都是公开可见的。

此处我们仍将隐私保护的智能合约抽象为复制状态机，将传递的输入替换为账本上记录的标识符，智能合约可以跟踪并验证这些标识符对应的输入信息。本节我们对基于复制状态机的智能合约模型进一步细化讨论，通过状态转移函数$\Gamma$来描述智能合约状态的变化$\Delta$，并构建隐私泄露函数$\Lambda_\sigma, \Lambda_\rho$用于分析在跟踪验证标识符对应输入的过程中发生的数据。
\subsection{智能合约状态转移}
如\autoref{fig:ch3-transfer}所示，基于隐私保护的智能合约状态应包含两部分：链上与链下。基于这一背景，本节中我们先分别提出链上与链下部分的状态交互模型，再给出系统状态转移函数，最后组合为隐私保护的链上链下协同计算状态转移模型$\Delta$。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-transfer}智能合约状态转移图}
\end{figure}

定义链下计算$\mathcal{O}_{\alpha}$为一个维护状态$\alpha$的交互式模块，假设$\alpha$初始状态为$\alpha_0$，当前的上下文为$z$，链下计算的运行脚本为$transcript$，向量$\vec{\alpha}$按执行顺序依次记录每次$transcript$的执行状态。那么$\mathcal{O}_{\alpha}$允许的交互如下：

\noindent\hrulefill
\begin{description}
\item 收到请求$q(transcript, \omega)$，使用隐私输入$\omega$执行$transcript$：\newline
if $\alpha = \perp$ then return $\perp$\newline
计算$(\alpha', r) \leftarrow q(transcript, \omega, z, \alpha)$\newline
$\alpha \leftarrow \alpha'$\newline
return $r$
\item 收到请求$apply$：\newline
$\vec{\alpha} \leftarrow \vec{\alpha} \parallel \alpha$
\item 收到请求$check$：\newline
return $(\vec{\alpha}, \alpha)$
\end{description}
\noindent\hrule
~\\

链上计算与链下类似，但是请求的内容不再包含隐私输入，而是用户创建的交易$\tau$。需要注意的是在链上与链下交互模型中虽然都存在上下文$z$，但是两者的具体内容并不相同，例如为了提供隐私保护，链下计算的上下文中会包含随机因子$\eta$。后续我们将具体讨论$z$中的内容。以下我们给出链上计算$\mathcal{O}_{\alpha}$允许的交互：

\noindent\hrulefill
\begin{description}
\item 收到请求$q(\tau)$：\newline
if $\alpha = \perp$ then return $\perp$\newline
计算$(\alpha', r) \leftarrow q(\tau, z, \alpha)$\newline
$\alpha \leftarrow \alpha'$\newline
return $r$
\item 收到请求$apply$：\newline
$\vec{\alpha} \leftarrow \vec{\alpha} \parallel \alpha$
\item 收到请求$check$：\newline
return $(\vec{\alpha}, \alpha)$
\end{description}
\noindent\hrule
~\\

与KACHAIN\cite{9505181}类似，我们使用状态转移函数来描述合约状态变更过程。设合约初始状态为$\varnothing$，在确定输入时，状态转移函数将给出固定的输出和对应的新状态。尽管为了隐私保护模型可能会引入随机流，但是这并不会影响状态转移函数的确定性。这是因为对于智能合约模型，一笔交易被创建后，其所需的随机参数都应被固定在内容中。

对此，我们给出系统状态转移函数$\Gamma$的声明，即$\Gamma:(\varnothing', c, y) \leftarrow f(\varnothing, p, z, \omega, a, \tau)$。其中，$\varnothing$表示初始状态；$\varnothing'$表示合约执行后的新状态；$p$为交易发起方；$a$表示系统中的对抗性输入，例如交易的执行顺序可能受到影响；$c$为交易的状态，包括被拒绝$\perp$与成功执行$\mathsf{T}$两种；$z$表示执行过程中的系统上下文；$\tau$表示交易。可以知道$\Gamma$实际可以由两部分构成：$\Gamma: (\Gamma_{\mathcal{O}_\sigma}, \Gamma_{\mathcal{O}_\rho})$。

基于维护状态$\alpha$的交互式模块的状态转移函数$\Gamma_{\mathcal{O}_\alpha}$，其执行流程如下：
\begin{center}
    状态转移函数$\Gamma_{\mathcal{O}_\alpha}$
\end{center}
\noindent\hrule
\begin{description}
    \item 给定输入：$q$
    \subitem send $q$ to $\mathcal{O}_\alpha$, receive $r$
    \subitem send $check$ to $\mathcal{O}_\alpha$, receive $(\vec{\alpha}, \alpha)$
    \subitem if $\alpha \neq \perp$, then send $apply$ to $\mathcal{O}_\alpha$
    \subitem return $(\vec{\alpha}, r)$
\end{description}
\noindent\hrule
~\\

最后根据上述定义和功能分析，我们给出基于隐私保护的链上链下协同计算模型的状态转移流程如下所示。
\begin{center}
    隐私保护的链上链下协同计算模型状态转移$\Delta$
\end{center}
\noindent\hrule
\begin{description}
    \item 给定输入：$(\sigma, \rho), p, \omega, a, z, \tau$
    \subitem let $(\sigma_{new}, \rho[p]_{new}, c, y') \leftarrow \Gamma(\sigma, \rho[p], p, \omega, z, a, \tau)$
    \subitem let $\sigma' \leftarrow \sigma, \rho' \leftarrow \rho, y \leftarrow \perp, C \leftarrow c$
    \subitem if $\sigma_{new} = \perp \vee \rho[p]_{new} = \perp$ then
        \subsubitem let $C \leftarrow \perp$
        \subsubitem break
    \subitem let $\sigma' \leftarrow \sigma_{new}, \rho'[p] \leftarrow \rho[p]_{new}, y \leftarrow y'$
    \subitem return $(\sigma', \rho'), C, y$
\end{description}
\noindent\hrule
\subsection{用户交易隐私泄露}
隐私泄露与状态转移的分离性是基于智能合约的执行逻辑造成的，当一笔交易被创建并提交后，其泄露的隐私数据已被固定，而后才通过智能合约的执行完成状态转移。因此我们可以对交互过程中隐私数据泄露进行独立建模，从而保证模型是具备隐私保护性质的。如前所述，交互中可能存在的输入点有两个，用户构建交易与链下计算节点计算时使用的输入。

对于用户创建交易造成的隐私泄露较为直观，因为交易一旦提交至链上账本都将公开可见，因此泄露的数据即为交易中的具体内容。自然地，我们给出用户交易隐私泄露函数$\Lambda_\sigma$的定义：$(desc, D, z) \leftarrow f(u, v)$。其中，$u$为创建交易的用户，$v$为用户u的智能合约视图，$desc$提供了对需要泄露的隐私数据精确描述，$z$表示一些可能需要的上下文信息，$D$则是对应交易在账本上所依赖的相关交易的记录集合。

对于用户$u$的智能合约视图$v$应该包含与$u$相关的账本信息，即账本中的智能合约相关状态$\sigma$，$u$所能看见的账本长度，$u$对应账本上未确认的交易集合。$desc$是函数返回中极为重要的一项，这是用户对自身泄露隐私情况的了解方式。当用户根据$desc$意识到发起交易泄露的隐私数据不符合预期时，可以取消创建交易避免隐私的意外泄露。因此隐私泄露函数作为隐私保护的必要前提在安全性分析中不应该存在恶意的修改或用于对手的模拟。
\subsection{链下计算隐私泄露}
基于NIZK的链下计算通过构建证明的方式在隐藏了隐私输入的同时提供对链下的验证，然而对于验证时所需的公共输入或交互中附加的数据仍会被暴露出来。需要强调的是此处对泄露的定义是指约束在合约上的可预见的数据泄露，是用户允许透露的信息。通过对约定泄露和未预期的数据泄露进行区分有助于后续验证模型的安全性和隐私保护能力。

进一步地，我们定义链下计算隐私泄露函数，即$\Lambda_\rho：(desc, D, z) \leftarrow f(p, v, transcript)$。与$\Lambda_\sigma$的定义相类似，$p$为创建交易的链下计算节点，$v$为$p$的智能合约视图，$desc$提供了对需要泄露的隐私数据精确描述，$z$表示一些可能需要的上下文信息，$D$则是对应交易在账本上所依赖的相关交易的记录集合。此处还需要提供链下计算节点上部署的NIZK计算脚本$transcript$作为补充输入。这是因为在链上验证链下计算的框架中，智能合约实际由链上的公开合约与链下计算脚本共同构成。
\section{协同计算交易}

\subsection{交易分段提交}

trans组+checkpoint
\subsection{交易依赖性分析}

\section{面向链上链下协同计算的通用协议}
\subsection{基于KACHAIN的前置建模}
简单账本模型

零知识证明
\subsection{协议概述}
基于前述的模型构建与分析，我们可以构造出面向链上链下协同计算的通用协议用来抽象化协同计算的整体过程。协议的核心思想为将一次完整的协同计算转化为两阶段执行：1）首先用户签署隐私泄露描述并构建一阶段交易调用智能合约方法，链上更新状态；2）在第二阶段中我们使用NIZK来证明链上合约与链下计算的交互过程，并在链上应用相关的公共状态。

其中需要NIZK证明的交互过程$\mathcal{L}$可以被描述为：定义$(\mathcal{T}_\rho, \omega) \in \mathcal{L}$，给定任意状态转移函数$\Gamma$，当且仅当$\mathcal{O}_\rho \leftarrow \mathcal{O}(\mathcal{T}_\rho, \omega)\wedge last(\Gamma_{\mathcal{O}_\rho}) \neq \perp$时，$apply(\mathcal{O}_\rho)$。

下面我们给出面向链上链下协同计算的通用协议的具体功能与执行逻辑。协议主要基于上述讨论的抽象智能合约与协同计算交易思想实现了理想情况下的协同计算，并被设计用于简单账本与NIZK的混合模型中。

\begin{center}
    面向链上链下协同计算的通用协议
\end{center}
\noindent\hrule
\begin{description}
    \item[初始状态] 账本状态$(\sigma, \rho) \leftarrow (\varnothing, \varnothing)$，已确认交易集合$S_\mathcal{T} \leftarrow \epsilon$，系统状态为$\mathsf{T}$
    
    \item[账本状态更新] 检查账本上交易，验证未确认交易的依赖与证明。
    
    如果满足条件，基于状态转移函数$\Gamma_{\mathcal{O}}$更新系统状态$(\sigma, \rho) \leftarrow (\sigma', \rho')$，将交易$\tau$标记为已确认交易$S_\mathcal{T} \leftarrow S_\mathcal{T}\parallel\tau$并返回必要的交易回执$y$

    对于失败的交易，系统返回拒绝信息并置为$\perp$

    \item[所有交互的前置条件] 更新账本状态，对于账本上被拒绝的交易，其他依赖于该笔交易的未确认交易也应被拒绝

    \item[收到用户$u$的提交请求$(\mathcal{T}_\sigma)$:] 两阶段执行
    
    \subitem [stage 1] 读取账本，获取当前状态$(\sigma_o, \rho_o)$，计算交易依赖$D_\sigma$，设置上下文信息$z_\sigma \leftarrow (\sigma_o, \rho_o, D_\sigma)$；将$\mathcal{T}_\sigma$标记为未确认交易并记录在账本中
    
    \subitem [stage 2] 读取账本，获取当前状态$(\sigma_o, \rho_o)$，计算交易依赖$D_\rho$，选取随机流$\eta$，设置上下文信息$z_\rho \leftarrow (\sigma_o, \rho_o, D_\rho, \eta)$；对于给定的链下计算节点$\mathit{p}$，构造交易$(\mathcal{T}_\rho, \omega_\rho)$，构建NIZK证明$\pi$验证$(\mathcal{T}_\rho, \omega_\rho) \in \mathcal{L}$，将$\mathcal{T}_\rho$标记为未确认交易，将$(\mathcal{T}_\rho, \pi)$记录在账本中

    \item[收到用户$u$的查询请求$(\tau)$:] 如果$\tau$存在于当前的账本视图中，检索账本返回与$\tau$相关的所有输出。
    
    \item[隐私泄露保证] 用户发起请求前应接受基于$\Lambda_\sigma$得到的用户隐私描述$desc_\sigma$,以确认发出的请求内容中所含数据隐私获得泄露许可；同理在构建$(\mathcal{T}_\rho, \omega_\rho)$前，隐私计算节点应接受$desc_\rho \leftarrow \Lambda_\rho$，确认NIZK证明$\pi$中泄露的数据是被同意的
\end{description}
\noindent\hrule

\subsection{UC框架下的协议描述}

\section{安全性分析}
哈哈