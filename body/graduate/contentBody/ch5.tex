\chapter{隐私保护协同计算协议的实现与优化}
本章将聚焦于如何高效实现上一章中提出的隐私保护协同计算协议，包括对协议实现方案描述以及对协议的性能优化改进策略。对于协议功能实现，我们介绍协议中的模块构成，并针对复杂功能组件介绍其详细实现策略。对于协议性能优化，我们从多轮计算下的请求交互与链下计算两个方面进行讨论，提出合理的优化策略以获得更高效的协同计算协议。
\section{功能实现}
本节主要给出协议的功能实现方案，我们首先给出实现方案中各模块的在协议中的主要作用，随后逐个论述具体的实现策略。
\subsection{模块划分}
从协议的实现上来看，如整个协议由两大主要部分构成，一部分是作为用户和链下计算节点交互中间层的链上计算模块，另一部分则是负责链下计算与NIZK实现的链下计算模块。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch5-structure}隐私保护协同计算协议功能模块划分}
\end{figure}

链上计算模块的主要功能有三个，响应用户请求从而创建协同计算，计算交易依赖，此外还包含状态转移的相关内容：链上计算、对链下计算请求的发起与回调处理。

链下计算模块较为独立，对外其负责响应链上请求，对内包含链下计算与NIZK算法的证明与验证。对于给定的链下计算脚本$transcript$，其主要工作流程如下：
\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 首先需要完成初始化设置并构建R1CS约束得到带setup信息的R1CS
    \item 收到链下计算请求：将通过计算模块生成witness（电路全部中间信号值），基于witness与带setup信息的R1CS生成证明
    \item 收到验证请求：带setup信息的R1CS验证证明的有效性
\end{enumerate}
\subsection{链上计算模块}%业务合约里的
链上计算模块需要实现与用户和链下计算节点的交互，其中根据协议定义的分段式提交，我们定义链上计算模块需要对接的接口信息：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 协同计算创建接口：负责根据用户请求的创建对应协同计算任务
    \item 链下计算证明接口：负责创建链下计算请求
    \item 链下计算验证接口：负责接收链下计算证明，并请求NIZK验证
\end{itemize}

\paragraph{协同计算} 总体来看，协同计算的创建由一笔用户交易开始，其结束应由一次链下计算交易的完成而告终。其结束包含两种可能，协同计算中定义的最后一笔交易执行成功或者协同计算中的任意一笔交易执行失败。因此对于每次用户请求，使用哈希来返回一个全局唯一的标识符。该标识符作为协同计算交易的判定贯穿在每一笔相关交易与请求中。

那么对于一次协同计算所处状态，我们通过检查账本中对应交易的执行信息即可确认。其包含三种可能状态：失败，成功与部分成功。失败代表最多只有用户提交创建协同计算的交易成功执行，成功则是协同计算中定义的所有交易都正常执行，而部分成功对应的交易完成情况介于两者之间。

\paragraph{状态转移} 状态转移的实现逻辑与上一章在协议中描述的基本一致。在执行前检查账本中是否已存在交易的所有前置依赖，不存在则拒绝该交易。对于链下计算交易来说，其状态转移的前提还需要验证附带的证明是否合法。链下的状态转移实际为隐式提交，当链下计算交易成功提交后，链下状态更新也被认可。

\subsection{链下计算模块}%避开代理合约
与链上计算模块相同，我们首先对链下计算模块实现接口进行定义。对于链下计算来说，其对外提供的功能除了支撑链上计算模块完成协议交互外，还需要提供对链下计算脚本的部署和可信化设置。因此，接口主要包括：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 编译接口：接收链下计算脚本，完成约束信息构建
    \item 可信化设置接口：接收约束信息，构建基于随机字符串的可公开证明验证密钥对
    \item 计算和证明接口：接收链下计算请求，完成witness计算与证明生成
    \item 验证接口：接收验证请求，验证证明的合法性
\end{itemize}

链下计算模块实现架构如\autoref{fig:ch5-zkpstructure}可以细分为两部分，第一部分负责编程语言到算数电路的转换，包括编译器和计算系统。第二部分则负责NIZK算法的生成和验证，包括Setup模块，Prove模块和Verify模块。
\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch5-zkpstructure}链下计算模块划分}
\end{figure}

\paragraph{电路编译} 根据前述工作\cite{\\}可以将问题编译的实现策略分为两类：使用高级程序语言，或使用电路描述语言来描述问题脚本。在这里我们基于circom电路描述语言构建编译器。这是因为虽然高级程序语言有助于降低使用者的学习成本，但是将其转换为电路约束算法复杂性更大从而导致编译性能较差；此外高级程序语言在使用时没有约束的相关概念，不当的编写容易导致问题中的约束缺失，从而降低链下计算的安全性。而电路描述语言则很好地解决了上述两个问题。

编译器完成电路语言到电路的转换，将编程语言中的语句转换为加法或者乘法门，而编译阶段能确定的常量也被编码到电路中，以便减少后续基于电路的计算的复杂度。其内容有：
1.	r1cs约束信息
2.	符号表，r1cs中相关信号的名称
3.	计算信息

\paragraph{计算系统} 在计算系统中需要提供公共输入和隐私输入。其中公共输入从链下计算请求中获取，隐私输入则从本地数据来源中获取。经过计算步骤得到电路全部中间信号的值，这些值的集合称为witness。witness中包含了计算的全部中间过程的信息，一般只有真正经过计算才能得到这些信息。

基于电路描述语言编译方案，计算系统需要根据编译结果计算电路描述语言给出的问题对应的witness。一种可选的方案是基于编译的中间结果重新将电路描述问题构建为高级程序语言编写的代码，再基于其原生的编译器生成可执行文件用于计算。此类方案存在的问题是重新恢复为高级程序语言再重新编译过程复杂耗时长。对此我们基于编译的结果即电路约束信息来直接计算。优化方案我们将在下一节的性能优化中作详细介绍。

\paragraph{证明与验证} 其主要包括三个步骤：setup，prove和verify。setup的主要产出是基于CRS构建的证明验证密钥对。prove方法则对R1CS约束转化后的QAP问题生成证明，输出被编码为JSON格式，其中包括计算结果、公开输入和Proof部分。verify基于验证密钥核验证明的正确性，结果是true或者false的二元结果，分别代表验证的通过和不通过。

\section{性能优化}
为取得更好的协议运行性能，本节主要从协同计算执行耗时角度提出针对性的协议优化策略。首先对于协同计算中多轮计算的情况，可以通过打包请求的方式减少节点交互带来的时延；此外从链下计算的执行效率上，我们给出对编译计算和约束构建的优化方案。
\subsection{针对多轮计算的优化策略}
针对协同计算中发往同一个链下计算节点的链下计算请求，则我们可以将其包含在同一次请求中。这样的好处在于将多轮链下计算请求合并为一轮，同时链下收到消息后可以并行完成打包中的多次请求。在实现中检查请求$a,b$是否可被打包在一起的主要算法逻辑如下：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item $a,b$请求属于同一次协同计算
    \item $a,b$请求发往同一个链下计算节点
    \item 对于打包中的请求$a, b$，其回调的链下计算交易分别为$\tau_{\rho_a}, \tau_{\rho_b}$，$a$中包含的公共输入并不会受$\tau_{\rho_b}$执行结果的影响，反之亦然。
\end{itemize}

\subsection{针对编译计算的优化策略}
如功能实现中所述，针对电路描述语言计算的复杂流程，我们考虑使用编译后的约束内容作为计算脚本直接得到电路信号值witness。为达成这一目标，我们首先需要对编译后的电路表示内容作调整，其次为进一步加快计算速度可以采用分组并行的方式执行。以下是优化后的编译计算大概流程：
\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 将使用自定义语言编写的用于描述问题的纯文本通过编译器转化为结构化的树形数据，具体执行了词法分析和语法分析两步来生成抽象语法树ast
    \item 深度优先遍历ast，构造电路约束并记录计算相关的语义信息
    \item 根据约束中涉及的参数，将相关联的约束分为一组，不同组间的计算可并行执行
    \item 输入公共参数值和隐私参数值，根据约束内容执行计算得到witness
\end{enumerate}

\paragraph{约束计算的可行性分析} 我们知道对于一段用于NIZK证明的链下计算代码，可以将其转化为电路约束。非正式的说，电路信号代表着代码中的变量，而由电路信号构成的约束系统是对计算代码的等价表示。那么对于一段逻辑正确的代码，给定输入，其中涉及的所有变量值在计算过程中是可以被确定的。同理对于由其转化来的电路约束，给定同样的输入也应该得到一致的电路信号值witness。

\paragraph{电路表示} 基于R1CS表示法，任何约束都可抽象为$a*b+c=0$的形式(后续使用QEX代指)，其中$a, b, c$均代表$\sum_{i=0}^{n}coef_i * signal_i$形式的多项式。当$a*b$项为0时，QEX被简化为了LC，即$\sum_{i=0}^{n}coef_i * signal_i = 0$。

基于该基本表示法，可以发现四则运算之外的其他复杂运算，如取模、左移等并不会纳入编译结果中。因此为了满足将R1CS约束用于计算的目的，我们增设了一个后缀表达式组$clues\leftarrow {(var:clue)}$用于记录无法在编译时确定具体取值的变量信息及复杂操作符，其中$var$为变量标识符，$clue$为其对应的后缀表达式。在计算阶段，我们将重新解析clues并代入信号值验证约束是否成立。在附录A中我们给出了一个例子来说明clues的具体构建方式。

特别地与原方案不同，我们对循环语句for和条件语句if进行了限定：循环次数和条件转移必须要在编译时被确定。这一限定合理的原因在于虽然原方案未在语法上作限制，但是实际上这类陈述将不受NIZK算法的保护，从而极可能在被篡改后仍通过算法验证。我们将这类限定明确提出，有助于保证链下计算脚本的合理性。基于以上说明，我们可以给出针对优化后的电路表示的执行流程：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 对变量赋值：更新变量的值，不能计算的部分用后缀表达式记录
    \item 对信号赋值：更新后缀表达式，并记录在clues表中
    \item 构建约束：使用QEX形式来标准化表示
\end{itemize}

\paragraph{分组并行} 见证计算可以分为两步：首先将根据约束中涉及到信号来划分问题集；其次我们可以多线程并行处理多个问题集，达到提高witness计算效率的目的。针对一个约束一般有三部分来描述：1. QEX形式；2. 相关信号的clue信息；3. 依赖约束。

对于一个r1cs文件都维护一个依赖列表，实现每个约束至自己所依赖的约束的映射。约束间的依赖主要是基于信号值计算之间的约束，对于一些约束（<==、==>）存在赋值关系，而赋值后的信号可能用于构建其他的约束，后者依赖于前者。对于相互依赖的约束我们将其划为一组进行串行计算，而在组间可以创建多线程并行执行。在附件B中我们给出一个约束分组的例子。线程数量可以根据计算环境自行决定。当组数大于规定的最大线程数时，每次合并组内数量最小的两个约束分组。

\subsection{针对电路约束的优化策略} NIZK算法的运行效率受约束规模影响较大，一般来说约束数量越多，参与约束的信号越多，则NIZK的执行耗时越长。对此，针对生成的R1CS约束需要进行优化，一个直观的思路是合并消元来减少中间变量。

电路优化的主要思想为：1）删去恒成立的约束；2）消去中间信号。对于第1类，在电路编写时可能错误构建了约束，即参与约束的所有信号值都可以在编译阶段得到，这样的约束没有意义。我们可以通过遍历计算来将这类约束删去。对于第2类，为避免出现R1CS无法表示的约束（即不可被归纳为QEX形式），可以进行消元的约束一定是LC形式。消元的具体步骤如\autoref{alg:ch5-1}所示。
\begin{breakablealgorithm}
    \caption{电路约束优化流程}
    \label{alg:ch5-1}
    \begin{algorithmic} 
        \item [输入]: 电路信号集合，约束集合，clues
        \item [初始化]: 
        
        待消约束集合$cset=$约束集合
        
        下一轮待消约束集合$nextcset=\varnothing$

        消元表$t$表示map(信号，LC约束),初始为空

        映射表$sig2cons$表示map(信号，约束集合)，初始保存所有映射关系：信号->包含该信号的全部约束
        \REPEAT
        \IF {$cset = \varnothing \wedge nextcset = \varnothing$}
        \STATE return 约束集合
        \ENDIF
        \IF {$cset = \varnothing$}
        \STATE let $cset \leftarrow nextcset, nextcset \leftarrow \varnothing$
        \ENDIF
        \STATE let $c \leftarrow $从$cset$中取出一条约束
        \IF {$c$不为LC形式}
        \STATE continue
        \ENDIF
        \STATE 提取最优待消信号$s$
        \STATE 将$c$转换为$s=LC$的格式存入$t$
        \IF {$sig2cons[s]\neq \varnothing$}
        \STATE 对$sig2cons[s]$中所有约束消元，并更新结果到$sig2cons$和约束集合
        \STATE 更新clues中含$s$的clue
        \STATE 将$sig2cons[s]$中所有约束加入$nextcset$
        \STATE 从约束集合和$sig2cons$中删除$c$
        \ENDIF
        \UNTIL {$1$}

    \end{algorithmic}
\end{breakablealgorithm}
其中待消信号$s$的选取有以下几个准则：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 不能为电路的输入输出信号
    \item 根据clues优先选取待计算信号
    \item 根据sig2cons优先选取涉及较多约束的信号
\end{itemize}