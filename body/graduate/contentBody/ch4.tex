\chapter{基于分段式提交的隐私保护协同计算协议}
协同计算状态更新协议规范了链上链下协同计算间的交互内容，基于上一章所述的通用模型安全实现了基于链下隐私计算的账本状态更新。本章我们主要围绕协议的设计进行叙述。首先，我们将阐明协议设计的动机与目标；其次，我们将逐一对协议的每个模块与流程作介绍；最后我们将基于UC安全框架论证协议的安全性，并指出针对协议的性能优化策略。
\section{设计动机与目标}
介绍现有方案的详细实现细节，在通用性（privacyGuard）和隐私保护的可用性（hybrid On/Off-chain）上存在问题
1. 链下计算请求未上链，无法留证，导致数据所有方无法信任请求方
2. 依赖于状态变更后的链下计算无法自动完成
\subsection{可用性}
对隐私保护问题的解决

\subsection{通用性}
对使用方与所有方分离场景的适用性

\subsection{高效性}
交互次数的降低

\subsection{安全性}

\section{协议概览}
本节我们主要从参与协议的角色和协议的内部组成两部分对协同计算账本更新协议作整体介绍。
\subsection{角色分类}
在上一章中我们对协同计算的基本模型所需角色进行了定义和说明，作为基于前文模型构建的协同计算账本更新协议，其对应的角色也包括发起协同计算的用户，链上节点和链下计算节点。用户发起一笔交易来创建一次协同计算，在后续的计算过程中，链上节点负责更新账本数据与链下计算节点的通信，链下计算节点则负责计算链下计算过程与零知识证明。一次协同计算的实现可能需要多轮的链下计算与账本更新。

\subsection{组成结构}
根据协同计算框架，我们可以发现链上节点担负了协议的核心功能并直接与用户和链下计算节点进行交互。因此我们可以对应地将协同计算账本更新协议划分为三个主要部分：链上合约模块，用户交互模块与链下交互模块。对于每一次协同计算的账本更新都需要三部分的共同运作才能达成。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch4-structure}协同计算流程图}
\end{figure}

如\autoref{fig:ch4-structure}所示，协同计算的交互过程中主要有三类消息：来自用户的协同计算请求，链上节点发起的链下计算请求与链下计算节点的结果提交请求。协同计算请求发生在用户交互模块中，对于一次协同计算，在整个系统运行中有且仅有一次该请求，并发生在所有请求前。链下计算请求与结果提交请求往往成对出现在链下交互模块中，一组对应了一次链下计算过程。而链上合约模块负责处理所有发向链上节点的请求，并完成一次账本的更新。

\section{协同计算中的分段式提交}
\subsection{简单分段式提交}
隐私保护的协同计算模型往往关注于链下证明在链上的验证过程，不过多讨论用户向链下计算节点发起创建证明的过程。我们认为这一部分是不容忽视的，在用户并未部署链下计算节点的场景下，一方面用户可能无法直接创建与链下计算节点的安全连接，另一方面出于留证等需求可能要求保留对链下计算的申请记录。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-twophase}分段式提交示意图}
\end{figure}

基于上述背景，我们考虑将一次链上链下协同计算过程通过一组交易的方式串联起来。通过分布式账本记录自然地留存计算过程中与链下计算节点的交互记录。另外把链上合约方法作为中间层处理用户请求链下计算结果的流程。如\autoref{fig:ch3-twophase}所示，在每笔交易执行过程中触发下一个链下计算请求。如果中间某个链下计算失败，我们将终止后续的请求流程，并把账本记录维护在最后一个成功执行的状态点。

由用户$u$发起的涉及一次基于$p$的链下计算的分段式交互流程如下所示。两段操作从失败回退上看是独立的原子操作，这意味着尽管在某段计算中出现失败会导致该阶段执行失败，但系统会回到上一个阶段执行完成的状态，保留了协同计算过程的部分正确信息。自然地，分段式协同计算可被扩展到涉及多方链下计算的场景中，详细内容我们将在下一小节中作阐述。

\begin{breakablealgorithm}
    \caption{简单分段式提交流程}
    \label{alg:ch3-7}
    \begin{algorithmic} 
        \item[收到来自用户$u$的交易]:$\tau_\sigma$
        \STATE let $(\sigma, y) \leftarrow \Gamma_{\mathcal{O}_\sigma}(\tau_\sigma)$
        \IF {$\sigma \neq \perp$}
        \STATE submit $\tau_\sigma$
        \STATE send $q_\rho$ to $p$
        \STATE return ($SUCCESS, y$)
        \ENDIF
        \STATE return ($REJECTED, \tau_\sigma$)
        \item[链下计算节点$p$收到请求]:$q_\rho(w)$
        \STATE let $(\rho, y) \leftarrow compute(q_\rho, w)$
        \IF {$\rho \neq \perp$} 
        \STATE send $\tau_\rho$
        \STATE return ($REJECTED, q_\rho$)
        \ENDIF
        \STATE return ($SUCCESS, y$)
        \item[收到来自链下计算节点$p$的交易]:$\tau_\rho$
        \STATE $(\sigma, \rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(\tau_\rho)$
        \IF {$\sigma \neq \perp$}
        \STATE submit $\tau_\rho$
        \STATE return ($SUCCESS, y$)
        \ENDIF
        \STATE return ($REJECTED, \tau_\rho$)
    \end{algorithmic}
\end{breakablealgorithm}

\subsection{复杂分段式提交}
在上节中，我们对涉及一次链下计算的单次协同计算过程进行了分析，介绍了分段式提交在协同计算中的交互方式。但是在复杂的协同计算应用中，可能需要多方链下计算的参与，一个朴素的思路是继续采用分段的方式通过交易链的形式将它们串联起来。然而这面临了多笔交易与请求的并发的问题，对此我们考虑通过依赖性分析解决协同计算的并发问题，随后给出复杂情况下的分段式提交流程。

\noindent\textbf{链下计算的依赖性分析}

在链上链下协同计算中除了链上交易的依赖性之外，还存在链下计算的依赖性。链下的依赖不需要作单独的统计，这是因为在我们的模型中链下计算请求是被动创建的，往往与一笔链上交易绑定在一起。接下来我们对这一定论作详细解释。

受限于本地状态，链下计算的依赖都基于同一链下计算节点的不同计算间。此时可以分为两种情况作讨论：
\begin{enumerate}
    \item 两次链下计算服务于同一次协同计算过程
    
    在一次协同计算间每次链下计算的调用都伴随着一次链上交易，因此两次计算一定存在必要的前后顺序并可以在合约逻辑中提前确定。此时只需要在请求中标识出其所属的合约逻辑即可区分出链下计算的执行顺序。
    \item 两次链下计算分属于不同的协同计算过程
    
    这一情况下若交易为串行执行，显然不同的协同计算过程发送请求时一定有先后区别。然而当并发执行交易时，两次链下计算请求可能同时到达链下节点，根据下述定理，我们可以依赖交易的顺序来确定。

    定理：两次链下计算的顺序可根据交易顺序间接确定

    证明：设存在并发的两次协同计算${cal}_1, {cal}_2$中都对同一链下计算节点$p$的创建请求，创建请求对应的链上交易分别为$\tau_{{cal}_1}^{before}, \tau_{{cal}_2}^{before}$，完成链下计算后用于更新状态的链上交易为$\tau_{{cal}_1}^{after}, \tau_{{cal}_2}^{after}$，链下计算请求分别为$q_{{cal}_1}, q_{{cal}_2}$。我们假设创建请求对应的链上交易对应正确顺序为$\tau_{{cal}_1}^{before} \prec \tau_{{cal}_2}^{before}$。如果序列化执行两次协同计算，前序的每笔交易都应早于后续的交易执行，因此$\tau_{{cal}_1}^{before} \prec \tau_{{cal}_2}^{before} \Rightarrow {cal}_1\prec{cal}_2 \Rightarrow (\tau_{{cal}_1}^{before}, \tau_{{cal}_1}^{after})\prec (\tau_{{cal}_2}^{before},\tau_{{cal}_2}^{after}) $。此外显然，协同计算内部的自然顺序为$\tau_{{cal}_1}^{before}\prec q_{{cal}_1} \prec \tau_{{cal}_1}^{after}, \tau_{{cal}_2}^{before}\prec q_{{cal}_2} \prec \tau_{{cal}_2}^{after}$。
    
    根据递推得，$\tau_{{cal}_1}^{before} \prec \tau_{{cal}_1}^{after} \prec \tau_{{cal}_2}^{before} \prec \tau_{{cal}_2}^{after}$，则$q_{{cal}_1} \prec q_{{cal}_2}$，与假设中的${cal}_1\prec{cal}_2$一致。
    
    综上所述，创建请求对应交易$\tau^{before}$的依赖关系决定了链下计算请求间的依赖关系。
\end{enumerate}

\noindent\textbf{链上交易的依赖性分析}

针对并发交易的执行，我们会发现如果不加约束极有可能导致不同的执行顺序会导致不同的执行结果。在本文中我们假设系统运行在一个封闭的仅由一些无恶意逻辑的方法构成的单一智能合约系统中，从而避免对不同合约执行间相互作用的讨论。实际上这一部分有待在后续工作中作进一步的补充。

基于上述假设，下面我们主要讨论在协同计算合约中一组交易间存在的依赖关系。一种做法是对于所有未经确认的交易，我们都严格按照其提交顺序作执行。当收到一笔新交易$\tau$时，我们将其附加到待确认交易集$U$末尾，即$U\parallel\tau$，而从$U$的头部开始依序执行交易。这一方案能有效解决交易间的冲突同时协议适配时对原系统的改动较小，但是我们仍需要指出串行化的执行将较大影响系统性能。

针对上述方案存在的问题，我们给出了对于并行交易执行系统的依赖性建模。实际上存在依赖的交易并不常见，往往涉及到对同一状态的修改或存在向同一链下计算节点发起请求时才可能会产生冲突。因此我们指出对于调换顺序会影响执行结果的交易之间应具有强依赖性，这些交易执行的顺序类似于计算过程中的关键路径。我们设定函数$dep$来创建交易的关键路径信息$D$。在协同计算过程中出现被拒绝的交易或请求，则其关键路径后的所有计算都不应该继续被创建或执行。

对此，我们给出对于一笔交易其对应依赖性分析函数为$dep(U, \mathcal{T}, z)$，其中$U$为当前未确认交易有序集合，$\mathcal{T}$为目标交易执行过程中对应的状态交互序列，$z$为当前上下文。且函数需满足以下约束：
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\setlength{\parskip}{0pt}
    \item 当恶意调用$dep$时，其返回结果不受以下的任意约束，我们默认其为空集合$\epsilon$
    \item 对于依赖性分析函数$dep$，其返回值应为按固定顺序排列的一组交易集合$X$，且$X \sqsubseteq U$
    \item 保证对于$U$的任意乱序排列$U'$，如果$X \sqsubseteq U'$，则按$U'$执行交易与按$U$执行将得到最终一致的账本状态
    \item 对于$U$中新增的一笔未确认交易$\tau$，对应交互序列为$\mathcal{T}_\tau$，当$\mathcal{T}_\tau$与$\mathcal{T}$中存在对同一状态变量的修改时将其加入$X$
\end{itemize}

\noindent\textbf{复杂分段式提交}

基于上述讨论，接下来我们针对不同方案下的多交易场景给出对应的分段式提交流程。其可以描述为：在由用户$u$发起的链上链下协同计算过程中，涉及$n$笔链上交易集合，对于每笔交易，执行时包含$m$次向任意链下计算节点发布的请求。

根据之前对交易和请求依赖的讨论，当链上串行化执行交易时，链下计算请求也无需交易依赖的支持，按照接收顺序依次执行。也就是说，与简单场景一致，在完成状态转移后交易就被提交到了分布式账本中。
\begin{algorithm}[H]
    \begin{algorithmic} 
        \item[收到交易]:$\tau$
        \STATE let $(\sigma, \rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(\tau)$
        \IF {$\sigma \neq \perp \wedge \rho \neq \perp$}
        \STATE submit $\tau$
        \FOR {$q_{p_i} \in Q_{\tau}$}
        \STATE send $q_{p_i}$ to $p_i$
        \ENDFOR
        \STATE return ($SUCCESS, y$)
        \ENDIF
        \STATE return ($REJECTED, \tau$)
        \item[链下计算节点$p$收到请求]:$q_\rho(w)$
        \STATE let $(\rho, y) \leftarrow compute(q, w)$
        \IF {$\rho \neq \perp$}
        \STATE send $\tau_\rho$
        \STATE return ($SUCCESS, y$)
        \ENDIF
        \STATE return ($REJECTED, q_\rho$)
    \end{algorithmic}
    \caption{\label{alg:ch3-6}串行化分段式提交流程}
\end{algorithm}

当并发执行交易和链下计算请求时，我们使用前述的依赖分析函数$dep$来计算交易对应的依赖信息$D$，在链下计算请求中也将附带$D$从而保证计算的正确执行顺序。在并发执行时，当收到一笔新交易时，我们按照将按照以下思路完成执行：1）更新账本状态与$U_\tau$；2）检查状态转移是否正确；3）计算交易依赖；4）将交易先记录到待确认集合$U_\tau$中；5）发送对应的链下计算请求。同理，链下计算也将基于集合$U_q$来缓存暂时无法确认的请求。

\begin{breakablealgorithm}
    \caption{并发分段式提交流程}
    \label{alg:ch3-8}
    \begin{algorithmic} 
        \item[收到交易]:$\tau$
        \STATE $(\sigma^o, \rho^o, U_\tau) \leftarrow updateWorld$
        \STATE let $\sigma \leftarrow \sigma^o, \rho \leftarrow \rho^o$
        \FOR {$u = (\mathcal{T}_\sigma, D) \in U_\tau$}
        \STATE $\mathcal{T}_\rho \leftarrow T(u)$
        \STATE $\sigma \leftarrow \mathcal{T}_\sigma(\sigma), \rho \leftarrow \mathcal{T}_\rho(\rho)$
        \ENDFOR
        \STATE let $z \leftarrow (\sigma^o, \rho^o, \sigma, \rho)$
        \STATE let $(\sigma', \rho', \mathcal{T}_\sigma, \mathcal{T}_\rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(\tau)$
        \IF {$\sigma' = \perp \vee \rho' = \perp$}
        \STATE return ($REJECTED, \tau$)
        \ENDIF
        \STATE let $D \leftarrow dep(U_\tau, \mathcal{T}_\sigma, z)$
        \STATE $\tau \leftarrow (\mathcal{T}_\sigma, D)$
        \STATE $U_\tau \leftarrow U_\tau \parallel \tau$
        \FOR {$q_{p_i} \in Q_{\tau}$}
        \STATE send $q_{p_i}(w, D)$ to $p_i$
        \ENDFOR
        \STATE query for submit $\tau$
        \STATE return ($POSTED, \tau$)
        \item[链下计算节点$p$收到请求]:$q_\rho(w, D)$
        \STATE $U_q \leftarrow U_q \parallel \tau_{q_\rho}$
        \REPEAT 
        \STATE $U_q \leftarrow read(U_q), C \leftarrow read(C)$
        \IF {$D \cap (U_q \cup C) = \epsilon$}
        \STATE return ($REJECTED, q_\rho$)
        \ENDIF
        \UNTIL {$D \cap U_q = \epsilon$}
        \STATE let $(\rho', y) \leftarrow compute(q_\rho, w)$
        \IF {$\rho' = \perp$}
        \STATE return ($REJECTED, q_\rho$)
        \ENDIF
        \STATE $\rho \leftarrow \rho'$, $U_q \leftarrow U_q / q_\rho$
        \STATE return ($SUCCESS, \tau_\rho$)
    \end{algorithmic}
\end{breakablealgorithm}

\section{面向链上链下协同计算的状态更新协议}
基于前述的模型构建与分析，我们可以构造出面向链上链下协同计算的通用协议用来抽象化协同计算的整体过程。协议的核心思想为将一次完整的协同计算转化为两阶段执行：1）首先用户签署隐私泄露描述并构建一阶段交易调用智能合约方法，链上更新状态；2）在第二阶段中我们使用NIZK来证明链上合约与链下计算的交互过程，并在链上应用相关的公共状态。

其中需要NIZK证明的交互过程$\mathcal{L}$可以被描述为：定义$(\mathcal{T}_\rho, \omega) \in \mathcal{L}$，给定任意状态转移函数$\Gamma$，当且仅当$\mathcal{O}_\rho \leftarrow \mathcal{O}(\mathcal{T}_\rho, \omega)\wedge last(\Gamma_{\mathcal{O}_\rho}) \neq \perp$时，$apply(\mathcal{O}_\rho)$。

下面我们给出面向链上链下协同计算的通用协议的具体功能与执行逻辑。协议主要基于上述讨论的抽象智能合约与协同计算交易思想实现了理想情况下的协同计算，并被设计用于简单账本与NIZK的混合模型中。

\begin{center}
    面向链上链下协同计算的状态更新协议
\end{center}
\noindent\hrule
\begin{description}
    \item[初始状态] 账本状态$(\sigma, \rho) \leftarrow (\varnothing, \varnothing)$，已确认交易集合$S_\mathcal{T} \leftarrow \epsilon$，系统状态为$\mathsf{T}$
    
    \item[账本状态更新] 检查账本上交易，验证未确认交易的依赖与证明。
    
    如果满足条件，基于状态转移函数$\Gamma_{\mathcal{O}}$更新系统状态$(\sigma, \rho) \leftarrow (\sigma', \rho')$，将交易$\tau$标记为已确认交易$S_\mathcal{T} \leftarrow S_\mathcal{T}\parallel\tau$并返回必要的交易回执$y$

    对于失败的交易，系统返回拒绝信息并置为$\perp$

    \item[所有交互的前置条件] 更新账本状态，对于账本上被拒绝的交易，其他依赖于该笔交易的未确认交易也应被拒绝

    \item[收到用户$u$的提交请求$(\mathcal{T}_\sigma)$:] 两阶段执行
    
    \subitem [stage 1] 读取账本，获取当前状态$(\sigma_o, \rho_o)$，计算交易依赖$D_\sigma$，设置上下文信息$z_\sigma \leftarrow (\sigma_o, \rho_o, D_\sigma)$；将$\mathcal{T}_\sigma$标记为未确认交易并记录在账本中
    
    \subitem [stage 2] 读取账本，获取当前状态$(\sigma_o, \rho_o)$，计算交易依赖$D_\rho$，选取随机流$\eta$，设置上下文信息$z_\rho \leftarrow (\sigma_o, \rho_o, D_\rho, \eta)$；对于给定的链下计算节点$\mathit{p}$，构造交易$(\mathcal{T}_\rho, \omega_\rho)$，构建NIZK证明$\pi$验证$(\mathcal{T}_\rho, \omega_\rho) \in \mathcal{L}$，将$\mathcal{T}_\rho$标记为未确认交易，将$(\mathcal{T}_\rho, \pi)$记录在账本中

    \item[收到用户$u$的查询请求$(\tau)$:] 如果$\tau$存在于当前的账本视图中，检索账本返回与$\tau$相关的所有输出。
    
    \item[隐私泄露保证] 用户发起请求前应接受基于$\Lambda_\sigma$得到的用户隐私描述$desc_\sigma$,以确认发出的请求内容中所含数据隐私获得泄露许可；同理在构建$(\mathcal{T}_\rho, \omega_\rho)$前，隐私计算节点应接受$desc_\rho \leftarrow \Lambda_\rho$，确认NIZK证明$\pi$中泄露的数据是被同意的
\end{description}
\noindent\hrule

\section{安全性分析}
\subsection{理想函数}

\subsection{协同计算协议的UC描述}
基于上述建模，我们给出链上链下协同计算协议在现实世界中的函数定义。在函数构造中我们通过转移函数$\Gamma$完成状态的转移，并用$desc$来代表协议的数据泄露，以及依赖分析函数$dep$计算交易中的依赖关系，从而在逻辑上概括分段式的协同计算过程。

我们设定协议运行在NIZK与简单账本的混合模型中$(\mathcal{F}_{nizk}^\mathcal{L}, \mathcal{G}_{simple})$，其中NIZK证明的交互过程$\mathcal{L}$可以被描述为：定义$(\mathcal{T}_\rho, \omega) \in \mathcal{L}$，给定任意状态转移函数$\Gamma$，当且仅当$\mathcal{O}_\rho \leftarrow \mathcal{O}(\mathcal{T}_\rho, \omega)\wedge last(\Gamma_{\mathcal{O}_\rho}) \neq \perp$时，$apply(\mathcal{O}_\rho)$。

\begin{algorithm}[H]
    \begin{algorithmic} 
        \STATE hellp
        \REQUIRE $n \geq 0 \vee x \neq 0$
        \ENSURE $y = x^n$
        \STATE $y \Leftarrow 1$
        \IF{$n < 0$}
            \STATE $X \Leftarrow 1 / x$
            \STATE $N \Leftarrow -n$
        \ELSE
            \STATE $X \Leftarrow x$
            \STATE $N \Leftarrow n$
        \ENDIF
        \WHILE{$N \neq 0$}
            \IF{$N$ is even}
                \STATE $X \Leftarrow X \times X$
                \STATE $N \Leftarrow N / 2$
            \ELSE[$N$ is odd]
                \STATE $y \Leftarrow y \times X$
                \STATE $N \Leftarrow N - 1$
            \ENDIF
        \ENDWHILE
    \end{algorithmic}
    \caption{\label{alg:function}链上链下协同计算安全协议}
\end{algorithm}

\subsection{UC证明}
