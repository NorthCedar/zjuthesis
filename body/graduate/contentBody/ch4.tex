\chapter{基于分段式提交的隐私保护协同计算协议}
协同计算状态更新协议规范了链上链下协同计算间的交互内容，基于上一章所述的通用模型安全实现了基于链下隐私计算的账本状态更新。本章我们主要围绕协议的设计进行叙述。首先，我们将阐明协议设计的动机与目标；其次，我们将逐一对协议的每个模块与流程作介绍；最后我们将基于UC安全框架论证协议的安全性，并指出针对协议的性能优化策略。
\section{设计动机与目标}
介绍现有方案的详细实现细节，在通用性（privacyGuard）和隐私保护的可用性（hybrid On/Off-chain）上存在问题
1. 链下计算请求未上链，无法留证，导致数据所有方无法信任请求方
2. 依赖于状态变更后的链下计算无法自动完成
\subsection{可用性}
对隐私保护问题的解决

\subsection{通用性}
对使用方与所有方分离场景的适用性

\subsection{安全性}


\section{协议概览}
本节我们主要从参与协议的角色和协议的内部组成两部分对协同计算账本更新协议作整体介绍。
\subsection{角色分类}
在上一章中我们对协同计算的基本模型所需角色进行了定义和说明，作为基于前文模型构建的协同计算账本更新协议，其对应的角色也包括发起协同计算的用户，链上节点和链下计算节点。用户发起一笔交易来创建一次协同计算，在后续的计算过程中，链上节点负责更新账本数据与链下计算节点的通信，链下计算节点则负责计算链下计算过程与零知识证明。一次协同计算的实现可能需要多轮的链下计算与账本更新。

\subsection{组成结构}
根据协同计算框架，我们可以发现链上节点担负了协议的核心功能并直接与用户和链下计算节点进行交互。因此我们可以对应地将协同计算账本更新协议划分为三个主要部分：链上合约模块，用户交互模块与链下交互模块。对于每一次协同计算的账本更新都需要三部分的共同运作才能达成。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch4-structure}协同计算流程图}
\end{figure}

如\autoref{fig:ch4-structure}所示，协同计算的交互过程中主要有三类消息：来自用户的协同计算请求，链上节点发起的链下计算请求与链下计算节点的结果提交请求。协同计算请求发生在用户交互模块中，对于一次协同计算，在整个系统运行中有且仅有一次该请求，并发生在所有请求前。链下计算请求与结果提交请求往往成对出现在链下交互模块中，一组对应了一次链下计算过程。而链上合约模块负责处理所有发向链上节点的请求，并完成一次账本的更新。

\section{协同计算中的分段式提交}
隐私保护的协同计算模型往往关注于链下证明在链上的验证过程，不过多讨论用户向链下计算节点发起创建证明的过程。我们认为这一部分是不容忽视的，在用户并未部署链下计算节点的场景下，一方面用户可能无法直接创建与链下计算节点的安全连接，另一方面出于留证等需求可能要求保留对链下计算的申请记录。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-twophase}分段式提交示意图}
\end{figure}

基于上述背景，我们考虑将一次链上链下协同计算过程通过一组交易的方式串联起来。通过分布式账本记录自然地留存计算过程中与链下计算节点的交互记录。另外把链上合约方法作为中间层处理用户请求链下计算结果的流程。如\autoref{fig:ch3-twophase}所示，在每笔交易执行过程中触发下一个链下计算请求。如果中间某个链下计算失败，我们将终止后续的请求流程，并把账本记录维护在最后一个成功执行的状态点。

下文我们将由浅入深讨论不同场景下的分段式提交，并分别给出具体的交互流程。需要注意的是在本节中，为了方便叙述我们忽略了链下计算的证明和验证过程，这一部分将在完整的隐私保护协同计算协议中作阐述。

\subsection{单次协同计算的分段式提交}
由用户$u$发起的涉及一次基于$p$的链下计算的分段式交互流程如下所示。两段操作从失败回退上看是独立的原子操作，这意味着尽管在某段计算中出现失败会导致该阶段执行失败，但系统会回到上一个阶段执行完成的状态，保留了协同计算过程的部分正确信息。
\begin{breakablealgorithm}
    \caption{单次分段式提交流程}
    \label{alg:ch4-1}
    \begin{algorithmic} 
        \item[前提条件]：当前账本状态$(\sigma, \rho) \leftarrow (\sigma^o, \rho^o)$
        \item[收到来自用户$u$的交易]:$\tau_u$
        \STATE let $\mathcal{T}_\sigma \leftarrow T(\tau_u)$
        \IF {$\mathcal{T}_\sigma(\sigma) \neq \perp$}
        \STATE let $\sigma \leftarrow \mathcal{T}_\sigma(\sigma)$
        \STATE send $q_p$ to $p$
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
        \item[链下计算节点$p$收到请求]:$q_p$
        \STATE let $(\sigma, \rho, \mathcal{T}_\sigma, \mathcal{T}_\rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(q_p)$
        \IF {$\sigma \neq \perp \wedge \rho \neq \perp$} 
        \STATE send $\tau_p$
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
        \item[收到来自链下计算节点$p$的交易]:$\tau_p$
        \STATE let $\mathcal{T}_\sigma \leftarrow T(\tau_p)$
        \IF {$\mathcal{T}_\sigma(\sigma) \neq \perp$}
        \STATE let $\sigma \leftarrow \mathcal{T}_\sigma(\sigma)$
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
    \end{algorithmic}
\end{breakablealgorithm}

自然地，分段式协同计算可被扩展到涉及多次链下计算的场景中。一个直观的思路是继续采用分段的方式通过交易链的形式将它们串联起来。其可以描述为：在由用户$u$发起的链上链下协同计算过程中，涉及$n$笔链上交易集合，对于每笔交易，执行时包含$m$次向任意链下计算节点发布的请求。为了方便叙述，我们定义函数$Q(\tau)$返回交易$\tau$指定的链下计算请求集合。此外我们将用户交易和链下计算节点发起的交易合在一起叙述。
\begin{breakablealgorithm}
    \caption{多次分段式提交流程}
    \label{alg:ch4-2}
    \begin{algorithmic} 
        \item[前提条件]：当前账本状态$(\sigma, \rho) \leftarrow (\sigma^o, \rho^o)$
        \item[收到交易]:$\tau$
        \STATE let $\mathcal{T}_\sigma \leftarrow T(\tau)$
        \IF {$\mathcal{T}_\sigma(\sigma) \neq \perp$}
        \STATE let $\sigma \leftarrow \mathcal{T}_\sigma(\sigma)$
        \FOR {$q_p \in Q(\tau)$}
        \STATE send $q_p$ to $p$
        \ENDFOR
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
        \item[链下计算节点$p$收到请求]:$q_p$
        \STATE let $(\sigma, \rho, \mathcal{T}_\sigma, \mathcal{T}_\rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(q_p)$
        \IF {$\sigma \neq \perp \wedge \rho \neq \perp$} 
        \STATE send $\tau_p$
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
    \end{algorithmic}
\end{breakablealgorithm}

\subsection{并发交互下的分段式提交}
在上节中，我们对单次协同计算过程进行了分析，介绍了分段式提交在协同计算中的交互方式。但是上述的交互存在一个前提条件，即每次的交互顺序始终正确。例如存在两个协同计算任务$a, b$，基于分段式提交的思想，$a, b$对应的交易集合为$tx_a, tx_b$，则上一节交互流程能够正确完成的\textbf{约束前提}为：对于$tx_a, tx_b$中依赖同一账本状态的两笔交易$\tau_a, \tau_b$应保证其固定的执行顺序。

显然上述的要求经常出现在实际的应用中，然而我们很难在实际环境中直接假设这一约束成立。这是因为在网络通信和链下计算并发并行的策略下，收到交易的顺序往往是混乱的。

一种简单的做法是强制所有的协同计算任务串行化执行。当收到来自用户的一笔协同计算创建交易时，我们将检查账本上是否存在仍未完成的协同计算任务，如果存在则拒绝创建请求。同时对于协同计算任务中的所有交易都必须在上一个交易提交到账本后再创建下一笔。

虽然这一方案能有效解决交易间的冲突同时协议适配时对原系统的改动较小，但是我们仍需要指出串行化的执行将较大影响系统性能。对此我们考虑通过交易依赖性分析解决协同计算的顺序问题，随后基于此给出最终的分段式提交流程。

\paragraph{交易的依赖性分析} 根据前文提到的并发交互下的分段式提交约束内容，我们可以进一步将出现冲突的场景作细化，并给出相应的解决方案：
\begin{enumerate}
    \item 由链下节点维护的账本状态$\rho$造成的冲突
    \subitem 由于链下节点账本的隔离性，能够造成冲突的交易一定由同一个链下计算节点发起。因此我们可以将问题转化为如何解决链下计算节点交易的冲突计算。
    \subitem 对此必须维护一个待确认交易集$U$，用于缓存尚未成功提交到区块链账本上的交易信息。当收到一次新的链下计算请求并成功构建一笔新交易$\tau$时，我们将其附加到待确认交易集末尾，即$U \leftarrow U\parallel\tau$。当确认该交易被成功应用到账本后则将其从$U$中删去，即$U \leftarrow U / \tau$。
    \subitem 若当前节点$p$收到新的链下计算请求，其对应的状态交互序列为$\mathcal{T}_\rho$，其对应将要创建的链下计算交易为$\tau_p$。显然我们可以直接将$U$作为$\tau_p$的依赖交易集。
    \subitem 然而实际上存在依赖的交易并不常见，只有涉及到对同一账本状态的修改才会产生冲突。因此我们指出对于调换顺序会影响执行结果的交易之间应具有强依赖性，这些交易执行的顺序类似于计算过程中的关键路径。进一步地，我们给出关键路径计算函数$D \leftarrow dep(U, \mathcal{T}_\rho)$来计算$\tau_p$实际依赖的最小交易集合，其具体逻辑如下：
    \begin{itemize}
        \setlength{\itemsep}{0pt}
        \setlength{\parsep}{0pt}
        \setlength{\parskip}{0pt}
            \item 对于依赖性分析函数$dep$，其返回值应为按固定顺序排列的一组交易集合$X$，且$X \sqsubseteq U$
            \item 保证对于$U$的任意乱序排列$U'$，如果$X \sqsubseteq U'$，则按$U'$执行交易与按$U$执行将得到最终一致的账本状态
            \item 对于$U$中新增的一笔未确认交易$\tau$，对应交互序列为$\mathcal{T}_\tau$，当$\mathcal{T}_\tau$与$\mathcal{T}$中存在对同一状态变量的修改时将其加入$X$
    \end{itemize}
    \subitem 需要注意的是对于一笔提交到账本后被拒绝的交易，在将其踢出$U$之外，还应将依赖于其的交易标记为被拒绝并踢出$U$。
    \item 由链上节点维护的账本状态$\sigma$造成的冲突
    \subitem 与链下计算不同，由于链上状态是公开可见的，因此可以直接根据交易的先后到达顺序作执行，并进行状态变更。
\end{enumerate}

\paragraph{复杂分段式提交} 基于上述讨论，接下来我们针对不同方案下的多交易场景给出对应的分段式提交流程。在本文中我们假设系统运行在一个封闭的仅由一些无恶意逻辑的方法构成的单一智能合约系统中，从而避免对不同合约执行间相互作用的讨论。

当并发执行交易和链下计算请求时，我们使用前述的关键路径计算函数$dep$来计算交易对应的依赖信息$D$，在链下计算交易中也将附带$D$从而保证正确执行顺序。其中$\Sigma$为当前账本已确认交易集合，$updateState$函数主要逻辑：1）根据$\Sigma$完成对$U$的初始化；2）基于$\Sigma$对应的账本状态$(\sigma, \rho)$依次执行$U$中交易并返回状态转移结果。

\begin{breakablealgorithm}
    \caption{并发分段式提交流程}
    \label{alg:ch3-8}
    \begin{algorithmic} 
        \item[前提条件]：当前账本状态$(\sigma, \rho) \leftarrow (\sigma^o, \rho^o)$
        \item[收到交易]:$\tau(D)$
        \IF {!($D \sqsubseteq \Sigma$)}
        \STATE return $REJECTED$
        \ENDIF
        \STATE let $\mathcal{T}_\sigma \leftarrow T(\tau)$
        \IF {$\mathcal{T}_\sigma(\sigma) \neq \perp$}
        \STATE let $\sigma \leftarrow \mathcal{T}_\sigma(\sigma)$
        \FOR {$q_p \in Q(\tau)$}
        \STATE send $q_p$ to $p$
        \ENDFOR
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
        \item[链下计算节点$p$收到请求]:$q_p$
        \STATE $(U, \sigma, \rho) \leftarrow updateState(\sigma, \rho)$
        \STATE let $(\sigma, \rho, \mathcal{T}_\sigma, \mathcal{T}_\rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(q_p)$
        \IF {$\sigma = \perp \vee \rho = \perp$} 
        \STATE return $REJECTED$
        \ENDIF
        \STATE let $D \leftarrow dep(U, \mathcal{T}_\rho)$
        \STATE let $\tau_p \leftarrow (D, \mathcal{T}_\sigma)$
        \STATE $U \leftarrow U \parallel \tau_p$
        \STATE send $\tau_p$
        \STATE return $SUCCESS$
    \end{algorithmic}
\end{breakablealgorithm}

\section{隐私保护协同计算协议UC-SC}
\subsection{理想函数}
本节我们将描述隐私保护协同计算协议的理想函数$\mathcal{F}_{sc}$。
\paragraph{Post} 该子函数负责处理用户$u$和链下计算节点$p$发起的请求，其中包含与理想账本函数$\mathcal{F}_{ledger}$、理想NIZK函数$\mathcal{F}_{NIZK}^\mathcal{L}$的协作。子函数具体逻辑描述如下：
\begin{breakablealgorithm}
    \caption{$\mathcal{F}_{Post}$}
    \label{alg:ch4-4}
    \begin{algorithmic} 
        \item[收到来自$u$的协同计算创建请求$(CREATE, w)$]:
        \STATE 1. 取账本状态 2. 执行状态转移 3. 记录T 4. 提交账本 5. 发送q
        \STATE 发送$(TX, \mathcal{T}_\sigma, \varnothing)$到敌手S，并收到回复$\tau_u$
        \IF {$T(\tau_u) \neq \perp \vee \tau_u = \perp$}
        \STATE return $\perp$
        \ENDIF
        \STATE let $T(\tau_u) \leftarrow (\mathcal{T}_\sigma, \varnothing, \varnothing)$
        \STATE 发送$(submit, \tau_u)$到$\mathcal{F}_{ledger}$
        \FOR {$q_d \in Q(CREATE)$}
        \STATE 发送$(COMPUTE, q_d)$到链下计算节点$d$
        \ENDFOR
        \STATE return $\tau_u$
        \item[收到来自$p$链下计算完成请求$(POST, (\mathcal{T}_\sigma, D, \pi))$]:
        \STATE 1. 取账本状态 2. 执行verify 3. 提交账本 4. 发送q
        \STATE 发送$(TX, \mathcal{T}_\sigma, D, \pi)$到敌手S，并收到回复$\tau_u$
        \IF {$T(\tau_u) \neq \perp \vee \tau_u = \perp$}
        \STATE return $\perp$
        \ENDIF
        \STATE let $\tau_p \leftarrow (\mathcal{T}_\sigma, D, \pi)$
        \STATE 发送$(submit, \tau_p)$到$\mathcal{F}_{ledger}$
        \FOR {$q_d \in Q(POST)$}
        \STATE 发送$(COMPUTE)$到链下计算节点$d$
        \ENDFOR
        \STATE return $\tau_p$
        \item[收到来自$u$的协同计算查询请求$(QUERY, \tau_u)$]:
        \STATE 1. 取账本状态 2. 执行verify 3. 更新sigma
        \IF {$T(\tau_u) \neq (u, \cdot, \cdot, \cdot, \cdot)$}
        \STATE return $\perp$
        \ENDIF
        \STATE let $\Sigma_u \leftarrow updateState(u)$
        \IF {$\tau_u \notin \Sigma_u$}
        \STATE return NOTFOUND
        \ENDIF
        \STATE let $\tau_f \leftarrow getLast(\Sigma_u, \tau_u)$
        
    \end{algorithmic}
\end{breakablealgorithm}

\paragraph{Compute} 该子函数主要负责处理链下计算节点收到的请求，同样包含与理想账本函数$\mathcal{F}_{ledger}$、理想NIZK函数$\mathcal{F}_{NIZK}^\mathcal{L}$的协作。子函数具体逻辑描述如下：

\subsection{协议实现}
本节中我们基于前述的模型构建和分析，给出完整的隐私保护协同计算协议。协议的核心思想为将一次协同计算过程拆分为多笔交易的方式执行，两笔交易之间通过链下计算请求的方式完成传递。对于账本状态$(\sigma, \rho)$的转移基于链下计算和链上计算共同完成，而账本的执行则是基于状态转移结果和使用NIZK算法核验链下计算合法性。

下面我们给出协议的文字化描述，我们定义协议的外部输入包含两类，请求创建协同计算的用户请求$CREATE$，和链下计算请求$COMPUTE$。而对应的分布式账本中包含两类交易：用户创建协同计算的交易$\tau_u$和链下计算节点回调的交易$\tau_p$。对于参与方$p$在协同计算中担任两种角色，即协同计算发起者$u$，或链下计算节点。当其作为链下计算节点收到链下计算请求时将构建对应的链下计算完成请求作为返回。
\begin{breakablealgorithm}
    \caption{隐私保护协同计算组合协议}
    \label{alg:ch4-10}
    \begin{algorithmic} 
        \item [\textbf{链上协议$\mathcal{P}_{Post}$}] 
        \item[收到来自$u$的协同计算创建请求$(CREATE)$]:
        \STATE 构建协同计算创建交易$\tau_u$，发送交易到分布式账本。
        \STATE 如果交易中存在链下计算请求，将发送请求$(COMPUTE)$到指定节点$p$。
        \item[收到来自$p$链下计算完成请求$(POST, (\mathcal{T}_\sigma, D, \pi))$]:
        \STATE 构建链下计算交易$\tau_p$，发送交易到分布式账本。 
        \STATE 如果交易中存在链下计算请求，将发送请求$(COMPUTE)$到指定节点$p$。
        \item[收到来自$u$的协同计算查询请求$(QUERY, \tau_u)$]:
        \STATE 验证账本中与$\tau_u$相关的交易的证明和依赖，并返回计算结果。

        \noindent\hrulefill
        \item [\textbf{链下协议$\mathcal{P}_{Compute}$}] 
        \item[获取账本状态]: 
        \STATE 设置账本初始状态$(\sigma, \rho) \leftarrow (\varnothing, \varnothing)$
        \STATE 检查账本上交易: 对于链下计算交易则验证账本交易中的依赖与证明，验证失败标记为被拒绝的交易。执行交易完成状态转移。状态不为$\perp$，标记为已确认交易并更新账本状态，否则标记为被拒绝的交易。
        \STATE 若其在待确认交易集合中则将其移出。
        \item[处理请求的前置条件]: 
        \STATE 重新获取账本状态，对于账本上被拒绝的交易，其他依赖于该笔交易的未确认交易也应被拒绝，并从待确认交易中移除。
        \item[收到来自$c$的链下计算请求$(COMPUTE)$]:
        \STATE 基于当前账本状态$(\sigma, \rho)$，执行待确认交易集合所有交易得到新的账本状态$(\sigma', \rho')$。
        \STATE 基于该状态执行$(COMPUTE)$请求的链下计算，得到对应的预期账本状态$(\sigma'', \rho'')$。计算对应的交易依赖$D$。
        \STATE 基于交易依赖和链下计算过程生成NIZK证明$\pi \leftarrow ((\mathcal{T}_\sigma, D), \mathcal{T}_\rho) \in \mathcal{L}$。
        \STATE 发送链下计算完成请求$(POST,(\mathcal{T}_\sigma, D, \pi))$到$c$，将返回结果$\tau_p$记录到待确认交易集合中。
    \end{algorithmic}
\end{breakablealgorithm}

\section{隐私保护协同计算协议的安全证明}
