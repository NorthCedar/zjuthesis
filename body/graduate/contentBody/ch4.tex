\chapter{基于分段式提交的隐私保护协同计算协议}
协同计算状态更新协议规范了链上链下协同计算间的交互内容，基于上一章所述的通用模型安全实现了基于链下隐私计算的账本状态更新。本章我们主要围绕协议的设计进行叙述。首先，我们将阐明协议设计的动机与目标；其次，我们将逐一对协议的每个模块与流程作介绍；最后我们将基于UC安全框架论证协议的安全性，并指出针对协议的性能优化策略。
\section{设计动机与目标}
介绍现有方案的详细实现细节，在通用性（privacyGuard）和隐私保护的可用性（hybrid On/Off-chain）上存在问题
1. 链下计算请求未上链，无法留证，导致数据所有方无法信任请求方
2. 依赖于状态变更后的链下计算无法自动完成
\subsection{可用性}
对隐私保护问题的解决

\subsection{通用性}
对使用方与所有方分离场景的适用性

\subsection{安全性}


\section{协议概览}
本节我们主要从参与协议的角色和协议的内部组成两部分对协同计算账本更新协议作整体介绍。
\subsection{角色分类}
在上一章中我们对协同计算的基本模型所需角色进行了定义和说明，作为基于前文模型构建的协同计算账本更新协议，其对应的角色也包括发起协同计算的用户，链上节点和链下计算节点。用户发起一笔交易来创建一次协同计算，在后续的计算过程中，链上节点负责更新账本数据与链下计算节点的通信，链下计算节点则负责计算链下计算过程与零知识证明。一次协同计算的实现可能需要多轮的链下计算与账本更新。

\subsection{组成结构}
根据协同计算框架，我们可以发现链上节点担负了协议的核心功能并直接与用户和链下计算节点进行交互。因此我们可以对应地将协同计算账本更新协议划分为三个主要部分：链上合约模块，用户交互模块与链下交互模块。对于每一次协同计算的账本更新都需要三部分的共同运作才能达成。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch4-structure}协同计算流程图}
\end{figure}

如\autoref{fig:ch4-structure}所示，协同计算的交互过程中主要有三类消息：来自用户的协同计算请求，链上节点发起的链下计算请求与链下计算节点的结果提交请求。协同计算请求发生在用户交互模块中，对于一次协同计算，在整个系统运行中有且仅有一次该请求，并发生在所有请求前。链下计算请求与结果提交请求往往成对出现在链下交互模块中，一组对应了一次链下计算过程。而链上合约模块负责处理所有发向链上节点的请求，并完成一次账本的更新。

\section{协同计算中的分段式提交}
隐私保护的协同计算模型往往关注于链下证明在链上的验证过程，不过多讨论用户向链下计算节点发起创建证明的过程。我们认为这一部分是不容忽视的，在用户并未部署链下计算节点的场景下，一方面用户可能无法直接创建与链下计算节点的安全连接，另一方面出于留证等需求可能要求保留对链下计算的申请记录。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=.3\linewidth]{logo/zju}
    \caption{\label{fig:ch3-twophase}分段式提交示意图}
\end{figure}

基于上述背景，我们考虑将一次链上链下协同计算过程通过一组交易的方式串联起来。通过分布式账本记录自然地留存计算过程中与链下计算节点的交互记录。另外把链上合约方法作为中间层处理用户请求链下计算结果的流程。如\autoref{fig:ch3-twophase}所示，在每笔交易执行过程中触发下一个链下计算请求。如果中间某个链下计算失败，我们将终止后续的请求流程，并把账本记录维护在最后一个成功执行的状态点。

下文我们将由浅入深讨论不同场景下的分段式提交，并分别给出具体的交互流程。需要注意的是在本节中，为了方便叙述我们忽略了链下计算的证明和验证过程，这一部分将在完整的隐私保护协同计算协议中作阐述。

\subsection{单次协同计算的分段式提交}
由用户$u$发起的涉及一次基于$p$的链下计算的分段式交互流程如下所示。两段操作从失败回退上看是独立的原子操作，这意味着尽管在某段计算中出现失败会导致该阶段执行失败，但系统会回到上一个阶段执行完成的状态，保留了协同计算过程的部分正确信息。
\begin{breakablealgorithm}
    \caption{单次分段式提交流程}
    \label{alg:ch4-1}
    \begin{algorithmic} 
        \item[前提条件]：当前账本状态$(\sigma, \rho) \leftarrow (\sigma^o, \rho^o)$
        \item[收到来自用户$u$的交易]:$\tau_u$
        \STATE let $\mathcal{T}_\sigma \leftarrow T(\tau_u)$
        \IF {$\mathcal{T}_\sigma(\sigma) \neq \perp$}
        \STATE let $\sigma \leftarrow \mathcal{T}_\sigma(\sigma)$
        \STATE send $q_p$ to $p$
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
        \item[链下计算节点$p$收到请求]:$q_p$
        \STATE let $(\sigma, \rho, \mathcal{T}_\sigma, \mathcal{T}_\rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(q_p)$
        \IF {$\sigma \neq \perp \wedge \rho \neq \perp$} 
        \STATE send $\tau_p$
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
        \item[收到来自链下计算节点$p$的交易]:$\tau_p$
        \STATE let $\mathcal{T}_\sigma \leftarrow T(\tau_p)$
        \IF {$\mathcal{T}_\sigma(\sigma) \neq \perp$}
        \STATE let $\sigma \leftarrow \mathcal{T}_\sigma(\sigma)$
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
    \end{algorithmic}
\end{breakablealgorithm}

自然地，分段式协同计算可被扩展到涉及多次链下计算的场景中。一个直观的思路是继续采用分段的方式通过交易链的形式将它们串联起来。其可以描述为：在由用户$u$发起的链上链下协同计算过程中，涉及$n$笔链上交易集合，对于每笔交易，执行时包含$m$次向任意链下计算节点发布的请求。为了方便叙述，我们定义函数$Q(\tau)$返回交易$\tau$指定的链下计算请求集合。此外我们将用户交易和链下计算节点发起的交易合在一起叙述。
\begin{breakablealgorithm}
    \caption{多次分段式提交流程}
    \label{alg:ch4-2}
    \begin{algorithmic} 
        \item[前提条件]：当前账本状态$(\sigma, \rho) \leftarrow (\sigma^o, \rho^o)$
        \item[收到交易]:$\tau$
        \STATE let $\mathcal{T}_\sigma \leftarrow T(\tau)$
        \IF {$\mathcal{T}_\sigma(\sigma) \neq \perp$}
        \STATE let $\sigma \leftarrow \mathcal{T}_\sigma(\sigma)$
        \FOR {$q_p \in Q(\tau)$}
        \STATE send $q_p$ to $p$
        \ENDFOR
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
        \item[链下计算节点$p$收到请求]:$q_p$
        \STATE let $(\sigma, \rho, \mathcal{T}_\sigma, \mathcal{T}_\rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(q_p)$
        \IF {$\sigma \neq \perp \wedge \rho \neq \perp$} 
        \STATE send $\tau_p$
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
    \end{algorithmic}
\end{breakablealgorithm}

\subsection{并发交互下的分段式提交}
在上节中，我们对单次协同计算过程进行了分析，介绍了分段式提交在协同计算中的交互方式。但是上述的交互存在一个前提条件，即每次的交互顺序始终正确。例如存在两个协同计算任务$a, b$，基于分段式提交的思想，$a, b$对应的交易集合为$tx_a, tx_b$，则上一节交互流程能够正确完成的\textbf{约束前提}为：对于$tx_a, tx_b$中依赖同一账本状态的两笔交易$\tau_a, \tau_b$应保证其固定的执行顺序。

显然上述的要求经常出现在实际的应用中，然而我们很难在实际环境中直接假设这一约束成立。这是因为在网络通信和链下计算并发并行的策略下，收到交易的顺序往往是混乱的。

一种简单的做法是强制所有的协同计算任务串行化执行。当收到来自用户的一笔协同计算创建交易时，我们将检查账本上是否存在仍未完成的协同计算任务，如果存在则拒绝创建请求。同时对于协同计算任务中的所有交易都必须在上一个交易提交到账本后再创建下一笔。

虽然这一方案能有效解决交易间的冲突同时协议适配时对原系统的改动较小，但是我们仍需要指出串行化的执行将较大影响系统性能。对此我们考虑通过交易依赖性分析解决协同计算的顺序问题，随后基于此给出最终的分段式提交流程。

\paragraph{交易的依赖性分析} 根据前文提到的并发交互下的分段式提交约束内容，我们可以进一步将出现冲突的场景作细化，并给出相应的解决方案：
\begin{enumerate}
    \item 由链下节点维护的账本状态$\rho$造成的冲突
    \subitem 由于链下节点账本的隔离性，能够造成冲突的交易一定由同一个链下计算节点发起。因此我们可以将问题转化为如何解决链下计算节点交易的冲突计算。
    \subitem 对此，链下计算节点必须维护一个待确认交易集$U$，用于缓存尚未成功提交到区块链账本上的交易信息。当收到一次新的链下计算请求并成功构建一笔新交易$\tau$时，我们将其附加到待确认交易集末尾，即$U \leftarrow U\parallel\tau$。当确认该交易被成功应用到账本后则将其从$U$中删去，即$U \leftarrow U / \tau$。
    \subitem 若当前节点$p$收到新的链下计算请求，其对应的状态交互序列为$\mathcal{T}_\rho$，其对应将要创建的链下计算交易为$\tau_p$。显然我们可以直接将$U$作为$\tau_p$的依赖交易集。
    \subitem 然而实际上存在依赖的交易并不常见，只有涉及到对同一账本状态的修改才会产生冲突。因此我们指出对于调换顺序会影响执行结果的交易之间应具有强依赖性，这些交易执行的顺序类似于计算过程中的关键路径。进一步地，我们给出关键路径计算函数$D \leftarrow dep(U, \mathcal{T}_\rho)$来计算$\tau_p$实际依赖的最小交易集合，其具体逻辑如下：
    \begin{itemize}
        \setlength{\itemsep}{0pt}
        \setlength{\parsep}{0pt}
        \setlength{\parskip}{0pt}
            \item 对于依赖性分析函数$dep$，其返回值应为按固定顺序排列的一组交易集合$X$，且$X \sqsubseteq U$
            \item 保证对于$U$的任意乱序排列$U'$，如果$X \sqsubseteq U'$，则按$U'$执行交易与按$U$执行将得到最终一致的账本状态
            \item 对于$U$中新增的一笔未确认交易$\tau$，对应交互序列为$\mathcal{T}_\tau$，当$\mathcal{T}_\tau$与$\mathcal{T}$中存在对同一状态变量的修改时将其加入$X$
    \end{itemize}
    \subitem 需要注意的是对于一笔提交到账本后被拒绝的交易，在将其踢出$U$之外，还应将依赖于其的交易标记为被拒绝并踢出$U$。
    \item 由链上节点维护的账本状态$\sigma$造成的冲突
    \subitem 由于链上状态是公开可见的，因此可以直接根据交易的先后到达顺序作执行，并进行状态变更。交易间如果产生冲突，则后提交的交易一定会被拒绝，从而保证不会出现像链下状态一样的隐藏错误提交。
\end{enumerate}

\paragraph{复杂分段式提交} 基于上述讨论，接下来我们针对不同方案下的多交易场景给出对应的分段式提交流程。在本文中我们假设系统运行在一个封闭的仅由一些无恶意逻辑的方法构成的单一智能合约系统中，从而避免对不同合约执行间相互作用的讨论。

当并发执行交易和链下计算请求时，我们使用前述的关键路径计算函数$dep$来计算交易对应的依赖信息$D$，在链下计算交易中也将附带$D$从而保证正确执行顺序。其中$\Sigma$为当前账本已确认交易集合，$updateState$函数主要逻辑：1）根据$\Sigma$完成对$U$的更新；2）基于$\Sigma$对应的账本状态$(\sigma, \rho)$依次执行$U$中交易并返回状态转移结果。

\begin{breakablealgorithm}
    \caption{并发分段式提交流程}
    \label{alg:ch3-8}
    \begin{algorithmic} 
        \item[前提条件]：当前账本状态$(\sigma, \rho) \leftarrow (\sigma^o, \rho^o)$
        \item[收到交易]:$\tau(D)$
        \IF {!($D \sqsubseteq \Sigma$)}
        \STATE return $REJECTED$
        \ENDIF
        \STATE let $\mathcal{T}_\sigma \leftarrow T(\tau)$
        \IF {$\mathcal{T}_\sigma(\sigma) \neq \perp$}
        \STATE let $\sigma \leftarrow \mathcal{T}_\sigma(\sigma)$
        \FOR {$q_p \in Q(\tau)$}
        \STATE send $q_p$ to $p$
        \ENDFOR
        \STATE return $SUCCESS$
        \ENDIF
        \STATE return $REJECTED$
        \item[链下计算节点$p$收到请求]:$q_p$
        \STATE $(U, \sigma, \rho) \leftarrow updateState(U, \sigma, \rho)$
        \STATE let $(\sigma, \rho, \mathcal{T}_\sigma, \mathcal{T}_\rho, y) \leftarrow \Gamma_{\mathcal{O}_\sigma, \mathcal{O}_\rho}(q_p)$
        \IF {$\sigma = \perp \vee \rho = \perp$} 
        \STATE return $REJECTED$
        \ENDIF
        \STATE let $D \leftarrow dep(U, \mathcal{T}_\rho)$
        \STATE let $\tau_p \leftarrow (D, \mathcal{T}_\sigma)$
        \STATE $U \leftarrow U \parallel \tau_p$
        \STATE send $\tau_p$
        \STATE return $SUCCESS$
    \end{algorithmic}
\end{breakablealgorithm}

\section{隐私保护协同计算协议}
本节中我们基于前述的模型构建和分析，给出完整的隐私保护协同计算协议。协议的核心思想为将一次协同计算过程拆分为多笔交易的方式执行，两笔交易之间通过链下计算请求的方式完成传递。对于账本状态$(\sigma, \rho)$的转移基于链下计算和链上计算共同完成，而对账本状态的应用前提则是链上计算的完成和使用NIZK算法核验链下计算合法性。

下面我们给出协议的文字化描述，我们定义协议的外部输入包含两类，会造成账本变化的post请求，和查询账本信息的check请求。其中post请求包含用户创建协同计算的交易$\tau_sigma$和链下计算节点回调的交易$\tau_\rho$。
\begin{breakablealgorithm}
    \caption{隐私保护协同计算协议}
    \label{alg:ch4-4}
    \begin{algorithmic} 
        \item[获取账本状态]: 
        \STATE 设置账本初始状态$(\sigma, \rho) \leftarrow (\varnothing, \varnothing)$
        检查账本上交易，验证账本交易中的依赖与证明。

        \item[所有交互的前置条件]: 更新账本状态，对于账本上被拒绝的交易，其他依赖于该笔交易的未确认交易也应被拒绝
        \item[收到$p$的请求]:$(post, \tau)$
        \STATE 读取账本，获取当前状态$(\sigma_o, \rho_o)$，计算交易依赖$D_\sigma$，设置上下文信息$z_\sigma \leftarrow (\sigma_o, \rho_o, D_\sigma)$；将$\mathcal{T}_\sigma$标记为未确认交易并记录在账本中
        \STATE 读取账本，获取当前状态$(\sigma_o, \rho_o)$，计算交易依赖$D_\rho$，选取随机流$\eta$，设置上下文信息$z_\rho \leftarrow (\sigma_o, \rho_o, D_\rho, \eta)$；对于给定的链下计算节点$\mathit{p}$，构造交易$(\mathcal{T}_\rho, \omega_\rho)$，构建NIZK证明$\pi$验证$(\mathcal{T}_\rho, \omega_\rho) \in \mathcal{L}$，将$\mathcal{T}_\rho$标记为未确认交易，将$(\mathcal{T}_\rho, \pi)$记录在账本中

        \item[收到$p$的请求]: $(check, \tau)$  
        \STATE 如果$\tau$存在于当前的账本视图中，检索账本返回与$\tau$相关的所有输出。
    \end{algorithmic}
\end{breakablealgorithm}

\section{安全性分析}
\subsection{理想函数}

\subsection{协同计算协议的UC描述}
基于上述建模，我们给出链上链下协同计算协议在现实世界中的函数定义。在函数构造中我们通过转移函数$\Gamma$完成状态的转移，并用$desc$来代表协议的数据泄露，以及依赖分析函数$dep$计算交易中的依赖关系，从而在逻辑上概括分段式的协同计算过程。

我们设定协议运行在NIZK与简单账本的混合模型中$(\mathcal{F}_{nizk}^\mathcal{L}, \mathcal{G}_{simple})$，其中NIZK证明的交互过程$\mathcal{L}$可以被描述为：定义$(\mathcal{T}_\rho, \omega) \in \mathcal{L}$，给定任意状态转移函数$\Gamma$，当且仅当$\mathcal{O}_\rho \leftarrow \mathcal{O}(\mathcal{T}_\rho, \omega)\wedge last(\Gamma_{\mathcal{O}_\rho}) \neq \perp$时，$apply(\mathcal{O}_\rho)$。

\begin{algorithm}[H]
    \begin{algorithmic} 
        \STATE hellp
        \REQUIRE $n \geq 0 \vee x \neq 0$
        \ENSURE $y = x^n$
        \STATE $y \Leftarrow 1$
        \IF{$n < 0$}
            \STATE $X \Leftarrow 1 / x$
            \STATE $N \Leftarrow -n$
        \ELSE
            \STATE $X \Leftarrow x$
            \STATE $N \Leftarrow n$
        \ENDIF
        \WHILE{$N \neq 0$}
            \IF{$N$ is even}
                \STATE $X \Leftarrow X \times X$
                \STATE $N \Leftarrow N / 2$
            \ELSE[$N$ is odd]
                \STATE $y \Leftarrow y \times X$
                \STATE $N \Leftarrow N - 1$
            \ENDIF
        \ENDWHILE
    \end{algorithmic}
    \caption{\label{alg:function}链上链下协同计算安全协议}
\end{algorithm}

\subsection{UC证明}
