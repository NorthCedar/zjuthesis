\chapter{国内外研究现状与研究趋势}
在本节中，我们将对国内外的相关工作研究现状作详细介绍以此论证本文工作的可行性与实际意义。

首先，我们指出链下计算是解决智能合约隐私保护问题的重要思路并介绍链下计算的具体定义，同时对当前链下计算的可选技术方案作分类介绍，为第三章构建基于可验证计算的隐私保护智能合约模型奠定基础。其次，我们进一步介绍用于智能合约隐私保护的计算框架，在这一部分我们将对支持链上链下计算的协同计算框架作详细论述，并分析现有工作的实现思路与存在的问题，并基于以上分析提出第四章中的隐私保护协同计算协议。此外针对协议的安全定义问题，我们将重点介绍UC安全理论，为第四章中协议的安全性证明提供背景介绍与方法论。最后，我们将针对可验证计算链下计算方案中的zk-SNRAKs技术作详细介绍，在阐述当前相关工作的设计思路后归纳其通用实现架构，用于论证第五章中的实现方案和优化策略。

\section{链下计算与技术选型}
正如第一章所述，数据的隐私保护与当前的区块链基本操作模式是相冲突的。为了确保处理结果的一致性与正确性，区块链网络中的每个节点都必须冗余执行账本上的所有交易。同时这也意味着，每个节点都必须知道并存储交易的具体内容和执行信息，否则将无法满足冗余执行的要求。

一个自然的想法是将需要隐藏的数据和计算转移到链下执行，由此我们将这一思路概括为链下计算。接下来，我们将对链下计算作详细定义，并给出当前存在的技术选型及其对应的优劣势。
\subsection{链下计算}
高度冗余保证了分布式账本不需要任何对外界的信任依赖即可达成对已提交交易的共识，从而构建起不可被修改的历史信息。因此在不破坏这一核心属性的前提下很难提出一种设计从区块链本身执行逻辑上解决隐私保护的问题。

对此，与其尝试解决这个固有难题，我们不如将目光转移到对链下的外部资源利用上。显然通过将原本由链上管理的计算过程转移到如第三方、链下的服务器等外部资源上，可以极大减少数据的泄露。然而简单地将这些原本受链上信任机制保护的内容直接转移到链下的做法显然是不被允许的。因此链下计算实现的关键在于明确本应用所需的区块链属性，尽可能减少方案对其的损害。那么链下计算可以定义为：\textbf{在不损害所需区块链属性的前提下，将计算和数据转移到链下外部资源的过程}。

在本文中我们的主要目标为区块链应用的隐私保护，因此接下来我们将对链下计算技术作分类描述并围绕是否具备隐私保护特性等方面进行综合比较。这些技术主要可以被分为四类：基于可验证计算的链下计算技术，基于冲突解决的链下计算技术，基于多方安全计算的链下计算技术和基于可信执行环境的链下计算技术。

\subsection{基于可验证计算的链下计算方案}
我们首先介绍基于可验证计算技术的链下计算方案。由于证明的存在，链上节点可以对提交的计算结果作非交互式的验证。

\paragraph{概念及其架构}
可验证计算使得链下计算在生成计算结果的同时可以生成对应的计算证明用于验证计算过程的正确性。随后链上节点负责验证该证明从而保证应用了正确的链下计算内容。对于一次链下计算来说，链下计算节点作为prover基于公共输入和隐私输入执行计算过程并生成对应的由密码学机制保证的证明内容。随后将该证明内容与计算结果、公共输入一起提交到区块链。而链上节点作为verifier将通过对应的验证合约对其作核验。由于可验证计算技术是该链下计算方案的核心，因此可验证计算技术的特性也将决定其对应链下计算方案具备的特性。因此我们在介绍其具体的实现方案之前，先对可验证计算技术的相关特性进行说明：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 零知识性：为保护隐私输入，即prover需要隐藏的链下计算输入，可验证计算生成的证明必须具备该属性。零知识证明确保没有泄露除了需要被证明的事实。
    \item 非交互性：为提高链下计算方案的整体效率，应保证在一轮交互中即可验证证明的正确性。交互式方案需要创建多笔交易，这一过程加大了区块链网络的负担和一次链下计算产生的交易验证花销。目前许多可验证计算方案都可基于启发式的Fiat-Shamir算法\cite{10.1007/3-540-47721-7_12}实现非交互式验证。
    \item 高效性：从高效性上看，我们可以将可验证计算过程划分为验证，证明生成和证明大小三个衡量尺度。对于需要在链上重复执行的验证过程来说，证明的大小和验证的复杂度极大地影响了整个区块链的吞吐量。因此一个理想的情况为，针对任何链下计算问题，证明的大小和验证复杂度都保持相对独立，且越小越好。证明的生成一般是可验证计算中较为耗时的部分。在链下计算中证明计算被放在链下从而可以充分使用链下计算资源并且避免重复执行。这一机制使得使用可验证计算作为链下计算方案显得更为合理，但是我们也应该从理论上尽可能降低证明生成的复杂度从而提高整体方案的可用性。
    \item 弱安全假设：所选用的可验证计算依赖的安全假设应该越少越好。极强的安全假设需要额外的信任机制，这是区块链应用所不愿意看到的。
\end{itemize}

\paragraph{相关工作}
可验证计算已经在一些特定的区块链应用上得到了工程实现。例如Zerocoin\cite{6547123}和Zerocash\cite{6956581}协议都被设计用于匿名转账交易。除了这类基于特定场景的工作之外，ZoKrates\cite{8726497}提出了一个基于可验证计算的通用链下计算框架。这些工作我们将在本章的最后一节中作详细说明。如前所述，可验证计算的技术选型将影响方案特性，因此我们接下来对可验证计算技术作分类介绍。
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item zk-SNARKs：zk-SNRAKs能够在一次交互中验证prover给出的证明且保证零知识性。需要证明的过程通常使用算数电路\cite{10.1145/2856449}或R1CS\cite{184425}（rank-1 constraint system）描述。我们将在本章最后一节作进一步介绍。
    
    这类方案的证明大小一般在常数级别，例如Groth16\cite{cryptoeprint:2016/260}在BN254曲线上的证明大小为127字节\cite{cryptoeprint:2005/133}。然而证明的生成时间复杂度与链下计算程序复杂度成拟线性关系，这一部分也是该方案在实现上的主要瓶颈。除此之外的验证过程是独立于计算复杂度之外的，这有助于在链上完成证明验证。

    而安全假设方面，zk-SNARKs需要基于一次性的信任设置来生成用于计算的公共字符串，根据具体实现方案可以将其分为针对每个计算的CRS与全局化的SRS。为减少信任假设，一些工作\cite{cryptoeprint:2017/1050, 7163032}将多方安全计算协议（MPC）应用于信任设置，从而保证当至少一个参与方诚实时该信任设置即为可信的。
    \item Bulletproofs：与zk-SNARKs不同，Bulletproofs\cite{8418611}无需可信设置。从证明大小上看其与计算程序的复杂度成对数相关，一般的小型程序对应证明大小在几KB范围内。证明的生成复杂度也是线性相关于计算复杂度。然而与zk-SNARKs不同的是其链上验证的复杂度也是线性的。这意味着一旦链下计算复杂度过大，链上验证将会变得极为昂贵。
    \item zk-STARKs：同样是无需信任设置的zk-STARKs\cite{cryptoeprint:2018/046}使用了AIR(algebraic intermediate representation)作为其核心思路。其将计算语句转换为高次多项式，但实际上AIR程序同样也能被扩展为算数电路的形式。但是这类方案的证明和验证复杂度都较高，分别为拟线性和多项式对数级别相关于计算复杂度。同时其证明大小也比另两类大得多，对于同样的小型程序其大小在数百KB左右。
\end{itemize}

\subsection{基于激励机制的链下计算方案}
本节我们将对基于激励机制的链下计算方案作概述。这类方法一般借用相应的游戏或机制设置来描述协议，从而通过使用筹码再分配的方式鼓励参与方对结果发出质疑从而通过冲突解决保证计算的正确性。其具体实现可以参考文献\cite{hurwicz_reiter_2006}。显然这类方法无法在收到计算结果主动作正确性的验证，只有存在冲突时才会重新确认计算结果，并拒绝错误的一方。一般来说为了实现上述的复杂流程，一次链下计算的提交可能需要经过多轮交互。

\paragraph{概念及其架构}
激励机制机制得以正常运作的基本假设是参与者都将理性做出自己的决定，其理性在于每个参与方都试图最大化自己的经济收益。这一假设下该机制才能使用经济手段鼓励参与者执行正确的计算或对错误计算发起挑战质疑，例如没收作恶方的账户和资产并给予诚实方奖励等。这些经济激励手段可以通过区块链系统原生支持的转账操作进行实现。

综上，在激励机制中参与者都将独立进行相同的链下计算并使用同样的公共输入，当一个参与者提交初始计算结果后，其他参与者可以选择是否对其进行挑战。一旦发生冲突，区块链将作为裁决方判定挑战的获胜者和失败者并给予相应的惩罚和奖励。然而区块链并不能在只存在一个结果声明时判断其是否正确，因此当存在错误计算结果时必须等待一个正确计算结果的出现。因此，一个合理的基于激励机制的链下计算方案必须确保两件事：1）当出现冲突时区块链作为裁决方必须能够裁决出正确的结果；2）不正确的计算结果总是能受到质疑。对于第一点，可以通过在提交计算结果时附带计算中间步骤来实现。当出现冲突时，链上节点将执行计算结果各自提交的计算步骤，从而判定哪一方的计算偏离正常轨道。对于第二点需要通过一个合理的激励机制来实现，即不正确的结果提交行为将导致其他参与方的经济利益遭到损害，而如果挑战者赢得冲突则将收到经济回报。

在实际实现中提交到链上的计算步骤可以被改为承诺的形式从而减少在链上的存储占用。另外研究者发现对冲突的裁决行为对性能的影响较大。因此针对这类方案的实现必须尽量降低裁决算法的复杂度或者使用一个合理的机制使参与者都倾向于提交正确结果从而减少裁决的发生。

\paragraph{相关工作}
如上所述，基于激励机制的相关工作必须解决以下两个问题：1）激励参与者验证链下计算结果并对不正确的结果提出质疑；2）降低链上裁决造成的性能损耗。

TrueBit\cite{2019arXiv190804756T}针对问题一给出了一个有效的机制设计，即为链下计算任务创建一个公共市场。用户可以在链上发布自己的链下计算任务，并由验证者执行相应的任务并提交结果。一旦计算结果并应用则验证者将收到用户的发布奖励。在TrueBit协议中将验证者作了划分，即给出初始计算结果的solver与对计算结果作核验的verifier。当verifier提交挑战后成为challenger。TrueBit指出当solver总是给出正确计算结果时，verifier将没有动力继续验证。因此协议强制了solver不时地提供一些错误的计算结果，从而激励verifier找到这些错误的到奖励。这保证了对计算结果作验证和质疑的确定性激励的存在。然而针对问题二TrueBit并未给出较好的方案。在解决冲突时，challenger和solver间使用交互式验证协议\cite{2016arXiv160605917J, Christian}来帮助区块链作裁决。相比于链上直接验证的高效性，通过使用二分查找来检测存在分歧的执行历史并将裁决经过多轮交互收拢到一个单独的执行步骤上这一过程是非常复杂的。然而在裁决中参与计算的所有输入都会被公开以便作核验。

而Arbitrum\cite{217511}也使用了类似的交互式协议来完成对冲突的裁决。与TrueBit不同的是，Arbitrum不再基于公共市场作验证，而是由一个较小的内部团体负责链下计算的验证。在链下计算被执行前，将首先指定其对应的团队成员。当链下计算在Arbitrum虚拟机上完成执行后，将通过团队成员投票决定是否接受该计算结果。如果共识结果一致，则直接将计算结果应用上链。否则将在链上对存在质疑的步骤作裁决。不同于TrueBit允许所有参与者进行质疑，该方案存在的一个问题是不在团队内的参与方必须信任团队做出的决定。此外链下计算将不再是完全隐私保护的，团队内成员将获取到相应的隐私数据，不诚实者可能将隐私数据泄露出去。

\subsection{基于多方安全计算的链下计算方案}
在本节中我们将对基于多方安全计算协议(MPC)的链下计算方案作介绍。在MPC协议下，链下计算无需多轮交互。链上节点将对每一笔收到的链下计算交易作验证从而决定是否确认该交易。

\paragraph{概念及其架构} 
MPC协议能够多方在不泄露自身隐私数据的同时使用各方的隐私输入用于计算一个公共结果。然而MPC协议在存在活跃攻击者的模型中并不适用，其安全性和可用性基于集群大多数为诚实者的假设\cite{cryptoeprint:2019/883}。同时MPC协议也要求应用能够容忍和腐败方共享必要内容。

基于MPC协议进行链下计算的核心思想为将多节点的链下计算过程看作是一次多方安全计算。通过使用秘密分享协议\cite{10.1145/359168.359176}，任何参与计算的节点都只能获取加密后的分享内容而无法得到其他节点的隐私数据。秘密分享协议确保了根据分享内容无法得到对应的初始隐私输入但是却可以将分享内容用于节点间的共同计算。只有当作恶节点超过协议阈值时，此时大部分本应只保留在本节点的分享内容被整合在一起，从而可以回溯得到原始的隐私输入。因此，攻击者只需破坏这一假设，即控制参与多方安全计算协议的大多数节点，即可得到计算中的隐私数据。

在使用MPC协议进行链下计算时，首先需要做初始化。初始化的工作内容为将链下计算程序使用MPC电路的方式表示并部署到对应的链下计算节点上。随后在MPC执行过程中将把隐私输入分割为秘密分享协议的内容，同时基于秘密分享协议将分享内容分散到各个链下节点中。对于公共输入在无需做隐藏，在计算过程中公开传递。最后在MPC定义里的所有链下计算完成后，应保证至少有一个节点输出最终结果及相关的审计信息。

根据前述说明，为保证MPC协议的安全性和可用性，其适用于不存在活跃的攻击者且具备较高机密性的场景。因此当选用MPC协议作为链下计算方案时应确保具备以下三个前提假设：传输保证，可公开审计和高效性\cite{8726497}。传输保证指对于每个参与方都应收到所需输入和最终结果。数据的传输过程不应被攻击者阻断，从而保证MPC协议不应丧失活性而导致计算失败\cite{Barak}。可公开审计的要求来源于MPC协议的前提假设，即集群中的大多数是诚实的。然而这一假设并不能在应用中完全保证。因此当一次MPC计算完全由恶意节点参与时，如果不存在外部审计将导致错误的结果被应用到链上，这是链下计算不愿意看到的。针对这一问题，适用于链下计算的MPC协议必须支持可公开审计，当结构提交上链后由独立于链下计算之外的审计角色来保证计算结果的正确性。对于审计过程可以交由链上节点通过智能合约的形式来完成，也可以将其交由链下独立的审计节点在结果提交后作验证。进一步地，为保证区块链应用的执行效率，应确保对应的MPC执行耗时和审计验证耗时不能过长。

\paragraph{相关工作} 
在文献\cite{8726574}中对基于MPC的链下计算作了通用建模，然而目前还不存在对其的完整实现。此外在初版的Enigma\cite{2015arXiv150603471Z}论述中提出了基于MPC的隐私保护链下计算方案，该方案的实现基于文献\cite{cryptoeprint:2014/075}中设计的可公开审计秘密分享MPC协议。然而正如我们将在下一节所指出的，Enigma\cite{enigma2019}的最终实现受限于其性能而改用了TEEs。无独有偶，另一个基于完全同态加密的理论设计方案\cite{10.5555/1834954}也被证实其存在性能缺陷\cite{10.1145/2046660.2046682}。近期一些工作\cite{cryptoeprint:2019/883, 10.1145/3372297.3417261}通过构建新型的MPC协议来保证传输，然而它们都无法提供可公开的审计信息。因此这类工作只能应用于集群大多数可信的前提假设下。此外存在一些工作利用区块链来提高MPC协议的公平性。通过以拍卖或彩票\cite{6956580, 2017arXiv170106726B}等作为背景问题来对退出MPC协议的参与方作惩罚。可以看到这类工作都基于特定目的来提高MPC的公平性而非将MPC应用于通用的链下计算方案。

\subsection{基于可信执行环境的链下计算方案}
在本节中，我们主要介绍基于可信执行环境(TEEs)实现的链下计算技术。在这一技术方案中，链下计算提交的交易可以直接验证其合法性，因此链上节点将对收到的每笔交易作验证，且一次链下计算的提交同样无需多轮交互。

\paragraph{概念及其架构} 
TEEs作为一种执行环境从硬件层面来保证数据和代码的可信性以及计算过程的正确执行\cite{10.1007/978-3-662-53887-6_7}。TEEs使用可信硬件来确保只有经过授权才可访问专用加密的地址空间并将包含对应区域的计算过程和外部进程作隔离。其对应的具体实现框架有很多，包括但不限于Intel SGX\cite{90}，ARM TrustZone\cite{Trustzone}。为实现安全可验证的远程计算过程，必须将TEEs与远端部署的验证协议相结合。对于验证协议来说，它主要的作用是允许协议调用者验证对端为经过身份认证且工作在安全硬件上的TEEs，随后由TEEs确保其正确执行了对应的程序。然而，正如过程所描述的，这些协议必须以信任安全硬件的制造商作为前提。对于远程协议的具体实现机制可以参考文献\cite{90}。

该远端安全计算方式也可应用于链下计算上，即将TEEs部署到链下节点上，并在链上智能合约逻辑中加入验证协议。在链下计算的开始前，用户将连接到提前部署了TEEs的链下节点上。无论该链下节点是由用户自己控制的，还是由可信第三方提供的，都不影响其信任假设。随后用户将申请在TEEs上部署所需的链下计算程序。在部署完成后TEEs将提供返回程序正确部署的证明给用户，用户通过验证即可确认该部署过程的合法性。需要注意的是，该验证基于可信硬件制造商提供的证书，而对此的信任是TEEs技术的信任假设所要求的。在检查成功后，用户将通过加密通道将计算所需的公共输入和隐私输入提交给链下节点并收到相应的计算结果。最后用户可以将该计算结果提交至链上。而为了确保该计算结果的正确性，链上节点必须确认该结果是由TEEs执行正确的链下计算程序得到的。对此TEEs将提供对该计算结果的证明并交由链上节点作验证。同样的，该证明的验证也基于对可信硬件制造商证书的信任。

\paragraph{相关工作} 
Enigma\cite{enigma2019}设计了使用Intel SGX作为TEEs方案的链下计算方案。该方案是对文献\cite{2015arXiv150603471Z}中使用多方安全计算协议进行链下计算的工程实现。Enigma支持将合约中的部分内容标记为隐私内容从而强制其在链下计算中进行并给出了较优的实现性能。然而该工作存在不能较好抵御针对TEEs的侧信道攻击问题\cite{217543}。而另一个使用TEEs技术的工作是Ekiden\cite{2018arXiv180405141C}。与Enigma支持链上计算不同，Ekiden将区块链作为一个单纯的状态持久化模块。一旦链下计算完成，TEEs会将计算结果直接返回给用户并更新链上状态。这也导致这一框架存在不支持链上计算的缺点。

\subsection{技术对比与评估}
\begin{table}[htbp]
    \caption{\label{tab:ch2-1}自动调节列宽的表格}
    \begin{tabularx}{\linewidth}{c|c|X<{\centering}}
        \hline
        \multicolumn{2}{c|}{学生信息} & hh \\ \hline
        xxx & xxxhhhhhhh & hh \\ \hline
        xxx & xxx & hhEkiden将区块链作为一个单纯的状态持久化模块。一旦链下计算完成，TEEs会将计算结果直接返回给用户并更新链上状态。这也导致这一框架存在不支持链上计算的缺点。 \\ \hline
        xxx & xxx & hh \\ \hline
    \end{tabularx}
\end{table}

\section{链上链下协同计算}
区块链的链上计算

\subsection{链下计算技术}

\subsection{状态检查基于链上验证}

zokrates
CoCo
Ekiden

\subsection{状态检查基于验证与链上计算}

Scalable and Privacy-preserving Design of
On/Off-chain Smart Contracts
PrivacyGuard
Zether
Hawk

\subsection{技术对比与评估}

加入表格，从对链的影响、效率、隐私性、目标场景几个角度进行对比分析

\section{链下计算技术}
主要从以下四个角度介绍，其中重点分析可验证计算的优缺点，强调约束构建流程耗时带来的问题

\subsection{安全多方计算}

\subsection{激励驱动设计}

\subsection{可信执行环境}

\subsection{可验证计算}

1. 可验证计算概念</br>
2. 可验证计算分类</br>
zk-STARKs</br>
BulletProofs</br>
zk-SNARKs</br>
a. 基于zk-SNARKs的智能合约框架</br>
zkay Hawk ZEXE </br>
b. 基于zk-SNARKs的语法规范</br>

\subsection{技术对比与评估}

加入表格，从安全性、隐私性、问题描述方式、计算与验证原理几个角度对比分析

\section{UC安全理论与KACHAIN模型}