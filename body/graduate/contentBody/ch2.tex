\chapter{国内外研究现状与研究趋势}
在本节中，我们将对国内外的相关工作研究现状作详细介绍以此论证本文工作的可行性与实际意义。

首先，我们指出链下计算是解决智能合约隐私保护问题的重要思路并介绍链下计算的具体定义，同时对当前链下计算的可选技术方案作分类介绍，为第三章构建基于可验证计算的隐私保护智能合约模型奠定基础。其次，我们进一步介绍用于智能合约隐私保护的计算框架，在这一部分我们将对支持链上链下计算的协同计算框架作详细论述，并分析现有工作的实现思路与存在的问题，并基于以上分析提出第四章中的隐私保护协同计算协议。此外针对协议的安全定义问题，我们将重点介绍UC安全理论，为第四章中协议的安全性证明提供背景介绍与方法论。最后，我们将针对可验证计算链下计算方案中的zk-SNRAKs技术作详细介绍，在阐述当前相关工作的设计思路后归纳其通用实现架构，用于论证第五章中的实现方案和优化策略。

\section{链下计算与技术选型}
正如第一章所述，数据的隐私保护与当前的区块链基本操作模式是相冲突的。为了确保处理结果的一致性与正确性，区块链网络中的每个节点都必须冗余执行账本上的所有交易。同时这也意味着，每个节点都必须知道并存储交易的具体内容和执行信息，否则将无法满足冗余执行的要求。

一个自然的想法是将需要隐藏的数据和计算转移到链下执行，由此我们将这一思路概括为链下计算。接下来，我们将对链下计算作详细定义，并给出当前存在的技术选型及其对应的优劣势。
\subsection{链下计算}
高度冗余保证了分布式账本不需要任何对外界的信任依赖即可达成对已提交交易的共识，从而构建起不可被修改的历史信息。因此在不破坏这一核心属性的前提下很难提出一种设计从区块链本身执行逻辑上解决隐私保护的问题。

对此，与其尝试解决这个固有难题，我们不如将目光转移到对链下的外部资源利用上。显然通过将原本由链上管理的计算过程转移到如第三方、链下的服务器等外部资源上，可以极大减少数据的泄露。然而简单地将这些原本受链上信任机制保护的内容直接转移到链下的做法显然是不被允许的。因此链下计算实现的关键在于明确本应用所需的区块链属性，尽可能减少方案对其的损害。那么链下计算可以定义为：\textbf{在不损害所需区块链属性的前提下，将计算和数据转移到链下外部资源的过程}。

在本文中我们的主要目标为区块链应用的隐私保护，因此接下来我们将对链下计算技术作分类描述并围绕是否具备隐私保护特性等方面进行综合比较。这些技术主要可以被分为四类：基于可验证计算的链下计算技术，基于冲突解决的链下计算技术，基于多方安全计算的链下计算技术和基于可信执行环境的链下计算技术。

\subsection{基于可验证计算的链下计算方案}
我们首先介绍基于可验证计算技术的链下计算方案。由于证明的存在，链上节点可以对提交的计算结果作非交互式的验证。

\paragraph{概念及其架构}
可验证计算使得链下计算在生成计算结果的同时可以生成对应的计算证明用于验证计算过程的正确性。随后链上节点负责验证该证明从而保证应用了正确的链下计算内容。对于一次链下计算来说，链下计算节点作为prover基于公共输入和隐私输入执行计算过程并生成对应的由密码学机制保证的证明内容。随后将该证明内容与计算结果、公共输入一起提交到区块链。而链上节点作为verifier将通过对应的验证合约对其作核验。由于可验证计算技术是该链下计算方案的核心，因此可验证计算技术的特性也将决定其对应链下计算方案具备的特性。因此我们在介绍其具体的实现方案之前，先对可验证计算技术的相关特性进行说明：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 零知识性：为保护隐私输入，即prover需要隐藏的链下计算输入，可验证计算生成的证明必须具备该属性。零知识证明确保没有泄露除了需要被证明的事实。
    \item 非交互性：为提高链下计算方案的整体效率，应保证在一轮交互中即可验证证明的正确性。交互式方案需要创建多笔交易，这一过程加大了区块链网络的负担和一次链下计算产生的交易验证花销。目前许多可验证计算方案都可基于启发式的Fiat-Shamir算法\cite{10.1007/3-540-47721-7_12}实现非交互式验证。
    \item 高效性：从高效性上看，我们可以将可验证计算过程划分为验证，证明生成和证明大小三个衡量尺度。对于需要在链上重复执行的验证过程来说，证明的大小和验证的复杂度极大地影响了整个区块链的吞吐量。因此一个理想的情况为，针对任何链下计算问题，证明的大小和验证复杂度都保持相对独立，且越小越好。证明的生成一般是可验证计算中较为耗时的部分。在链下计算中证明计算被放在链下从而可以充分使用链下计算资源并且避免重复执行。这一机制使得使用可验证计算作为链下计算方案显得更为合理，但是我们也应该从理论上尽可能降低证明生成的复杂度从而提高整体方案的可用性。
    \item 弱安全假设：所选用的可验证计算依赖的安全假设应该越少越好。极强的安全假设需要额外的信任机制，这是区块链应用所不愿意看到的。
\end{itemize}

\paragraph{相关工作}
可验证计算已经在一些特定的区块链应用上得到了工程实现。例如Zerocoin\cite{6547123}和Zerocash\cite{6956581}协议都被设计用于匿名转账交易。除了这类基于特定场景的工作之外，ZoKrates\cite{8726497}提出了一个基于可验证计算的通用链下计算框架。这些工作我们将在本章的最后一节中作详细说明。如前所述，可验证计算的技术选型将影响方案特性，因此我们接下来对可验证计算技术作分类介绍。
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item zk-SNARKs：zk-SNRAKs能够在一次交互中验证prover给出的证明且保证零知识性。需要证明的过程通常使用算术电路\cite{10.1145/2856449}或R1CS\cite{184425}（rank-1 constraint system）描述。我们将在本章最后一节作进一步介绍。
    
    这类方案的证明大小一般在常数级别，例如Groth16\cite{cryptoeprint:2016/260}在BN254曲线上的证明大小为127字节\cite{cryptoeprint:2005/133}。然而证明的生成时间复杂度与链下计算程序复杂度成拟线性关系，这一部分也是该方案在实现上的主要瓶颈。除此之外的验证过程是独立于计算复杂度之外的，这有助于在链上完成证明验证。

    而安全假设方面，zk-SNARKs需要基于一次性的信任设置来生成用于计算的公共字符串，根据具体实现方案可以将其分为针对每个计算的CRS与全局化的SRS。为减少信任假设，一些工作\cite{cryptoeprint:2017/1050, 7163032}将多方安全计算协议（MPC）应用于信任设置，从而保证当至少一个参与方诚实时该信任设置即为可信的。
    \item Bulletproofs：与zk-SNARKs不同，Bulletproofs\cite{8418611}无需可信设置。从证明大小上看其与计算程序的复杂度成对数相关，一般的小型程序对应证明大小在几KB范围内。证明的生成复杂度也是线性相关于计算复杂度。然而与zk-SNARKs不同的是其链上验证的复杂度也是线性的。这意味着一旦链下计算复杂度过大，链上验证将会变得极为昂贵。
    \item zk-STARKs：同样是无需信任设置的zk-STARKs\cite{cryptoeprint:2018/046}使用了AIR(algebraic intermediate representation)作为其核心思路。其将计算语句转换为高次多项式，但实际上AIR程序同样也能被扩展为算术电路的形式。但是这类方案的证明和验证复杂度都较高，分别为拟线性和多项式对数级别相关于计算复杂度。同时其证明大小也比另两类大得多，对于同样的小型程序其大小在数百KB左右。
\end{itemize}

\subsection{基于激励机制的链下计算方案}
本小节我们将对基于激励机制的链下计算方案作概述。这类方法一般借用相应的游戏或机制设置来描述协议，从而通过使用筹码再分配的方式鼓励参与方对结果发出质疑从而通过冲突解决保证计算的正确性。其具体实现可以参考文献\cite{hurwicz_reiter_2006}。显然这类方法无法在收到计算结果主动作正确性的验证，只有存在冲突时才会重新确认计算结果，并拒绝错误的一方。一般来说为了实现上述的复杂流程，一次链下计算的提交可能需要经过多轮交互。

\paragraph{概念及其架构}
激励机制机制得以正常运作的基本假设是参与者都将理性做出自己的决定，其理性在于每个参与方都试图最大化自己的经济收益。这一假设下该机制才能使用经济手段鼓励参与者执行正确的计算或对错误计算发起挑战质疑，例如没收作恶方的账户和资产并给予诚实方奖励等。这些经济激励手段可以通过区块链系统原生支持的转账操作进行实现。

综上，在激励机制中参与者都将独立进行相同的链下计算并使用同样的公共输入，当一个参与者提交初始计算结果后，其他参与者可以选择是否对其进行挑战。一旦发生冲突，区块链将作为裁决方判定挑战的获胜者和失败者并给予相应的惩罚和奖励。然而区块链并不能在只存在一个结果声明时判断其是否正确，因此当存在错误计算结果时必须等待一个正确计算结果的出现。因此，一个合理的基于激励机制的链下计算方案必须确保两件事：1）当出现冲突时区块链作为裁决方必须能够裁决出正确的结果；2）不正确的计算结果总是能受到质疑。对于第一点，可以通过在提交计算结果时附带计算中间步骤来实现。当出现冲突时，链上节点将执行计算结果各自提交的计算步骤，从而判定哪一方的计算偏离正常轨道。对于第二点需要通过一个合理的激励机制来实现，即不正确的结果提交行为将导致其他参与方的经济利益遭到损害，而如果挑战者赢得冲突则将收到经济回报。

在实际实现中提交到链上的计算步骤可以被改为承诺的形式从而减少在链上的存储占用。另外研究者发现对冲突的裁决行为对性能的影响较大。因此针对这类方案的实现必须尽量降低裁决算法的复杂度或者使用一个合理的机制使参与者都倾向于提交正确结果从而减少裁决的发生。

\paragraph{相关工作}
如上所述，基于激励机制的相关工作必须解决以下两个问题：1）激励参与者验证链下计算结果并对不正确的结果提出质疑；2）降低链上裁决造成的性能损耗。

TrueBit\cite{2019arXiv190804756T}针对问题一给出了一个有效的机制设计，即为链下计算任务创建一个公共市场。用户可以在链上发布自己的链下计算任务，并由验证者执行相应的任务并提交结果。一旦计算结果并应用则验证者将收到用户的发布奖励。在TrueBit协议中将验证者作了划分，即给出初始计算结果的solver与对计算结果作核验的verifier。当verifier提交挑战后成为challenger。TrueBit指出当solver总是给出正确计算结果时，verifier将没有动力继续验证。因此协议强制了solver不时地提供一些错误的计算结果，从而激励verifier找到这些错误的到奖励。这保证了对计算结果作验证和质疑的确定性激励的存在。然而针对问题二TrueBit并未给出较好的方案。在解决冲突时，challenger和solver间使用交互式验证协议\cite{2016arXiv160605917J, Christian}来帮助区块链作裁决。相比于链上直接验证的高效性，通过使用二分查找来检测存在分歧的执行历史并将裁决经过多轮交互收拢到一个单独的执行步骤上这一过程是非常复杂的。然而在裁决中参与计算的所有输入都会被公开以便作核验。

而Arbitrum\cite{217511}也使用了类似的交互式协议来完成对冲突的裁决。与TrueBit不同的是，Arbitrum不再基于公共市场作验证，而是由一个较小的内部团体负责链下计算的验证。在链下计算被执行前，将首先指定其对应的团队成员。当链下计算在Arbitrum虚拟机上完成执行后，将通过团队成员投票决定是否接受该计算结果。如果共识结果一致，则直接将计算结果应用上链。否则将在链上对存在质疑的步骤作裁决。不同于TrueBit允许所有参与者进行质疑，该方案存在的一个问题是不在团队内的参与方必须信任团队做出的决定。此外链下计算将不再是完全隐私保护的，团队内成员将获取到相应的隐私数据，不诚实者可能将隐私数据泄露出去。

\subsection{基于多方安全计算的链下计算方案}
在本小节中我们将对基于多方安全计算协议(MPC)的链下计算方案作介绍。在MPC协议下，链下计算无需多轮交互。链上节点将对每一笔收到的链下计算交易作验证从而决定是否确认该交易。

\paragraph{概念及其架构} 
MPC协议能够多方在不泄露自身隐私数据的同时使用各方的隐私输入用于计算一个公共结果。然而MPC协议在存在活跃攻击者的模型中并不适用，其安全性和可用性基于集群大多数为诚实者的假设\cite{cryptoeprint:2019/883}。同时MPC协议也要求应用能够容忍和腐败方共享必要内容。

基于MPC协议进行链下计算的核心思想为将多节点的链下计算过程看作是一次多方安全计算。通过使用秘密分享协议\cite{10.1145/359168.359176}，任何参与计算的节点都只能获取加密后的分享内容而无法得到其他节点的隐私数据。秘密分享协议确保了根据分享内容无法得到对应的初始隐私输入但是却可以将分享内容用于节点间的共同计算。只有当作恶节点超过协议阈值时，此时大部分本应只保留在本节点的分享内容被整合在一起，从而可以回溯得到原始的隐私输入。因此，攻击者只需破坏这一假设，即控制参与多方安全计算协议的大多数节点，即可得到计算中的隐私数据。

在使用MPC协议进行链下计算时，首先需要做初始化。初始化的工作内容为将链下计算程序使用MPC电路的方式表示并部署到对应的链下计算节点上。随后在MPC执行过程中将把隐私输入分割为秘密分享协议的内容，同时基于秘密分享协议将分享内容分散到各个链下节点中。对于公共输入在无需做隐藏，在计算过程中公开传递。最后在MPC定义里的所有链下计算完成后，应保证至少有一个节点输出最终结果及相关的审计信息。

根据前述说明，为保证MPC协议的安全性和可用性，其适用于不存在活跃的攻击者且具备较高机密性的场景。因此当选用MPC协议作为链下计算方案时应确保具备以下三个前提假设：传输保证，可公开审计和高效性\cite{8726497}。传输保证指对于每个参与方都应收到所需输入和最终结果。数据的传输过程不应被攻击者阻断，从而保证MPC协议不应丧失活性而导致计算失败\cite{Barak}。可公开审计的要求来源于MPC协议的前提假设，即集群中的大多数是诚实的。然而这一假设并不能在应用中完全保证。因此当一次MPC计算完全由恶意节点参与时，如果不存在外部审计将导致错误的结果被应用到链上，这是链下计算不愿意看到的。针对这一问题，适用于链下计算的MPC协议必须支持可公开审计，当结构提交上链后由独立于链下计算之外的审计角色来保证计算结果的正确性。对于审计过程可以交由链上节点通过智能合约的形式来完成，也可以将其交由链下独立的审计节点在结果提交后作验证。进一步地，为保证区块链应用的执行效率，应确保对应的MPC执行耗时和审计验证耗时不能过长。

\paragraph{相关工作} 
在文献\cite{8726574}中对基于MPC的链下计算作了通用建模，然而目前还不存在对其的完整实现。此外在初版的Enigma\cite{2015arXiv150603471Z}论述中提出了基于MPC的隐私保护链下计算方案，该方案的实现基于文献\cite{cryptoeprint:2014/075}中设计的可公开审计秘密分享MPC协议。然而正如我们将在下一节所指出的，Enigma\cite{enigma2019}的最终实现受限于其性能而改用了TEEs。无独有偶，另一个基于完全同态加密的理论设计方案\cite{10.5555/1834954}也被证实其存在性能缺陷\cite{10.1145/2046660.2046682}。近期一些工作\cite{cryptoeprint:2019/883, 10.1145/3372297.3417261}通过构建新型的MPC协议来保证传输，然而它们都无法提供可公开的审计信息。因此这类工作只能应用于集群大多数可信的前提假设下。此外存在一些工作利用区块链来提高MPC协议的公平性。通过以拍卖或彩票\cite{6956580, 2017arXiv170106726B}等作为背景问题来对退出MPC协议的参与方作惩罚。可以看到这类工作都基于特定目的来提高MPC的公平性而非将MPC应用于通用的链下计算方案。

\subsection{基于可信执行环境的链下计算方案}
在本小节中，我们主要介绍基于可信执行环境(TEEs)实现的链下计算技术。在这一技术方案中，链下计算提交的交易可以直接验证其合法性，因此链上节点将对收到的每笔交易作验证，且一次链下计算的提交同样无需多轮交互。

\paragraph{概念及其架构} 
TEEs作为一种执行环境从硬件层面来保证数据和代码的可信性以及计算过程的正确执行\cite{10.1007/978-3-662-53887-6_7}。TEEs使用可信硬件来确保只有经过授权才可访问专用加密的地址空间并将包含对应区域的计算过程和外部进程作隔离。其对应的具体实现框架有很多，包括但不限于Intel SGX\cite{90}，ARM TrustZone\cite{Trustzone}。为实现安全可验证的远程计算过程，必须将TEEs与远端部署的验证协议相结合。对于验证协议来说，它主要的作用是允许协议调用者验证对端为经过身份认证且工作在安全硬件上的TEEs，随后由TEEs确保其正确执行了对应的程序。然而，正如过程所描述的，这些协议必须以信任安全硬件的制造商作为前提。对于远程协议的具体实现机制可以参考文献\cite{90}。

该远端安全计算方式也可应用于链下计算上，即将TEEs部署到链下节点上，并在链上智能合约逻辑中加入验证协议。在链下计算的开始前，用户将连接到提前部署了TEEs的链下节点上。无论该链下节点是由用户自己控制的，还是由可信第三方提供的，都不影响其信任假设。随后用户将申请在TEEs上部署所需的链下计算程序。在部署完成后TEEs将提供返回程序正确部署的证明给用户，用户通过验证即可确认该部署过程的合法性。需要注意的是，该验证基于可信硬件制造商提供的证书，而对此的信任是TEEs技术的信任假设所要求的。在检查成功后，用户将通过加密通道将计算所需的公共输入和隐私输入提交给链下节点并收到相应的计算结果。最后用户可以将该计算结果提交至链上。而为了确保该计算结果的正确性，链上节点必须确认该结果是由TEEs执行正确的链下计算程序得到的。对此TEEs将提供对该计算结果的证明并交由链上节点作验证。同样的，该证明的验证也基于对可信硬件制造商证书的信任。

\paragraph{相关工作} 
Enigma\cite{enigma2019}设计了使用Intel SGX作为TEEs方案的链下计算方案。该方案是对文献\cite{2015arXiv150603471Z}中使用多方安全计算协议进行链下计算的工程实现。Enigma支持将合约中的部分内容标记为隐私内容从而强制其在链下计算中进行并给出了较优的实现性能。然而该工作存在不能较好抵御针对TEEs的侧信道攻击问题\cite{217543}。而另一个使用TEEs技术的工作是Ekiden\cite{2018arXiv180405141C}。与Enigma支持链上计算不同，Ekiden将区块链作为一个单纯的状态持久化模块。一旦链下计算完成，TEEs会将计算结果直接返回给用户并更新链上状态。这也导致这一框架存在不支持链上计算的缺点。

\newpage
\subsection{技术对比与评估}
\begin{table}[htbp]
    \caption{\label{tab:ch2-1}链下计算方案对比}
    \begin{tabularx}{\linewidth}{c|c|c|X<{\centering}}
        \toprule [1pt]
        \multirow{2}*{} & \multicolumn{3}{c}{\textbf{可验证计算}} \\ \cline{2-4}
         & \textbf{zk-SNARKs} & \textbf{Bulletproofs} & \textbf{zk-STARKs} \\ \hline
        隐私输入 & 是 & 是 & 是 \\ \hline
        链上验证 & \makecell[c]{可信设置复杂度：$O(n)$ \\ 验证复杂度：$O(1)$ \\ 证明大小：$O(1)$ \\ $n$为计算电路乘法\\门数量} & \makecell[c]{验证复杂度：$O(n)$ \\ 证明大小：$O(\log n)$ \\ $n$为计算电路乘法\\门数量} & \makecell[c]{验证复杂度：$O(\log^2n)$ \\ 证明大小：$O(\log^2n)$ \\ $n$为计算电路(AIR转换后)\\乘法门数量} \\ \hline
        链下计算 & $O(n\log n)$ & $O(n)$ & $O(n\log^2n)$ \\ \hline
        安全假设 & \makecell[c]{指数知识假设KEA\\与可信设置} & 离散对数问题 & 抗碰撞哈希函数CRHF \\ \hline
        计算程序 & 算术电路 & 算术电路 & AIR(可转换为电路) \\ 
        \midrule [1pt]
        & \textbf{激励机制} & \textbf{MPC} & \textbf{TEEs} \\ \hline
        隐私输入 & 否 & 是 & 是 \\ \hline
        链上验证 & 二分查找复杂度\cite{2019arXiv190804756T}：$O(\log n)$ & \makecell[c]{链上审计复杂度：$O(n)$ \\ 审计内容大小：$O(n)$ \\ $n$为计算电路中门的数量\cite{cryptoeprint:2014/075}} & TEEs验签\cite{217543}：$O(1)$ \\ \hline
        链下计算 & VM生成执行历史 & $O(n)$ & TEEs证明生成 \\ \hline
        安全假设 & \makecell[c]{以最大化经济收益\\为目标的理性参与者} & \makecell[c]{诚实参与者数量\\达到协议阈值} & 信任TEEs证书 \\ \hline
        计算程序 & 编译后的VM指令集 & 布尔/算术电路 & 由TEEs编译后的机器码 \\ 
        \bottomrule [1pt]
    \end{tabularx}
\end{table}
在2.1中我们主要讨论和比较了链下计算方案，在阐明其核心思路后对相关工作进行了介绍。对此我们发现基于激励机制的链下计算方案虽然有助于区块链的扩展但不提供完全的隐私保护，一些协议\cite{217511, 8750913}采用将数据在选定范围内传播的方式降低隐私泄露风险。而针对TEEs方案，可以看到基于可信硬件制造商的额外信任极大损害了区块链的原生弱信任特性。而基于MPC协议的方案需要同时保证通信的不可阻断和可公开审计，目前满足该条件的工作还有待进一步实现。

因此通过分析，我们认为基于可验证计算的链下计算方案成为一个较为理想的解决思路。尤其对于使用zk-SNARKs的技术方案，其在提供较强计算隐私保护的同时，可以通过非交互式的形式在链上快速验证计算的正确性且无需过多的链上存储空间。在安全假设上可将必须的可信设置优化为一个全局性的过程，并使用MPC协议来进一步降低其信任依赖。

然而上述对工作往往将链下计算方案都将重心放在了链下计算在链上验证的框架描述上，对于如何在隐私保护的前提下使用链下计算在链上进行协同计算并没有过多的介绍，这也促使我们作进一步的调研。

\section{协同计算协议与协议安全}
 在本节中我们尝试从协同计算的角度对现有的工作进行总结介绍。正如上一节所提到的，我们在对链下计算方案进行总结之后发现将链下计算的结果应用于链上计算将是用于智能合约隐私保护的一个重要思路。对此我们试图加大调研的深度和广度，将目光放在协同计算框架的相关工作上，评估相关工作的应用通用性和隐私保护特性，以期获得相应启发。除了从协议功能性上进行调研，我们还通过介绍UC安全理论为后续讨论协议安全性提供理论支持。
\subsection{协同计算协议}
多年来如何在不涉及可信第三方的场景下在互不信任的多方之间构建信任机制一直是一个难题。比特币\cite{bitcoin}的提出和应用使得区块链技术成为解决去中心化的信任构建的一个理想方式。当前我们发现主要存在链上与链下计算两种基于区块链的协议形式尝试扩展将区块链的应用从单纯的加密货币领域扩展到通用性应用上。链上计算我们定义为由链上节点负责的智能合约执行过程，这一部分往往是公开透明的从而为去中心化信任机制提供支持。而这也大大限制了区块链应用的扩展性和隐私性，对此链下计算应运而生。正如上一节所提到的，链下计算将计算和数据迁移到了链下节点上，即将智能合约放在链下执行，可以看到研究人员尝试通过各类技术在减少对区块链特性的同时完成这项工作。然而单纯使用链下计算方案使得一些需要多方完成的智能合约行为变得难以实现，因此我们意识到使用链上链下混合架构有助于解决这一问题。

在加密货币应用\cite{bitcoinbook}中已提出采用混合架构提供隐私保护的需求，文献\cite{poon2016bitcoin}为解决比特币网络的延展性将小额支付转移到链下并通过使用新型的signhash对交易作签名的方式在链上作记录从而强制保证链下执行的可靠性。而在智能合约上，文献\cite{idelberger2016evaluation}提出了基于逻辑的智能合约概念，他们指出可以使用逻辑语言构建智能合约，从而提供链上链下执行的对应接口。然而这一方案的主要问题是当前的区块链系统中缺乏对此类逻辑语言的支持。文献\cite{9823371}设计了系统化方案用于多方参与的智能合约构建，然而这项工作的重心更多是在链上合约的协同性和更新性上，并未涉及对链下计算的讨论。

针对技术层面的协同计算，工作\cite{7516828}主要从软件设计的角度指出可以将链上合约作为桥梁连接链下的计算，并给出在设计层面的权衡依据。此外Jimenez等人\cite{10.1007/978-3-030-10549-5_27}基于数据买卖市场的应用背景描述了使用协同计算技术的可行性和必要性，同时提供了使用可信第三方执行器负责链下计算的协议思路。遗憾的是这两个工作都未讨论其详细的技术实施细节。随后，Jimenez等人在另一篇工作\cite{molina2018implementation}提出了使用合约合规检查器CCC\cite{CCC}的解决方案，在这一协议中CCC被部署在可信第三方节点TTP上负责检查链下合约的合规性和正确执行，TTP还负责在链下计算完成后与链上合约作交互。然而这一方案仍然受限于可信第三方的原始架构。

此外Enigma\cite{2015arXiv150603471Z}给出了基于安全多方计算的协同计算协议，然而正如之前所述，Enigma的后续技术实现改用了TEEs，MPC协议存在的传输保证和性能问题在该方案中未能有效解决。Li等人\cite{li2019scalable}对协同计算协议作了进一步优化。他们将智能合约划分为轻量透明的链上合约和计算量大或需要隐私保护的链下合约。通过激励机制来约束链下计算行为，当对链下计算出现分歧时需要挑战者与结果提交者都提供签名后的VM运行字节码交由链上节点作裁决。可以看到这一方案对智能合约的协同计算给出了更明确的功能划分和交互逻辑，同时避免了对于原生合约语言的修改。然而一旦产生冲突，正如其他激励机制所遵循的，链下计算的逻辑将被公开到链上节点作判决，这可能会造成链下数据隐私的泄露。此外研究者也尝试给出基于可验证计算的协同计算框架，例如Hawk\cite{7546538},Zkay\cite{2020arXiv200901020B}等，然而其在通用性和安全性上都存在各自的缺陷，我们将在下一章作详细介绍。

综上所述，我们看到目前针对智能合约的协同计算工作尚不能满足区块链应用在隐私保护和通用性上的共同要求，对此我们将在第四章中对这一问题进行详细分析并给出能够满足此类需求的协同计算协议。接下来我们对协议安全性理论作进一步介绍。
\subsection{UC安全框架}
对协议安全性的研究可以看作是协议设计的重要组成部分。Goldwasser和Micali\cite{10.1145/800070.802212}指出若敌手无法从消息密文中提取到消息的任何信息则此消息具备语义安全。而协议的安全性可进一步根据语义安全来度量，即协议运行中应保证敌手无法提取到足够多的信息来动摇协议的目标功能。一般来说为保证协议安全实现既定目标，需要满足两个要求：1）使用合适的数学模型定义协议内容；2）在协议模型中完成形式化的安全定义。其中安全定义应该直观给出协议在各种情况下都应实现给定功能，基于模拟的协议安全性论证成为理想的解决途径。基于模拟的技术\cite{10.1145/22145.22178}希望通过验证协议在理想环境和现实环境中行为不可区分而论证现实协议与理想协议具备相同的安全性。正式表述为：
\begin{center}
    $\forall A, \exists S, \forall Z, EXEC^{\gamma, A}_Z \thickapprox EXEC^{\digamma, S}_Z$\cite{cryptoeprint:2007/102}
\end{center}
简单来说，将环境$Z$作为区分器，对于任意真实环境中的敌手$A$都存在一个对应的理想环境中的模拟器$S$，使得$Z$无法根据协议输出区分当前的交互是通过真实环境协议$\gamma$还是理想环境协议$\digamma$。此时，在保证理想环境协议$\digamma$具备足够安全性的前提下，真实环境协议$\gamma$具备同样的安全性。

为进一步定义“不可区分”，密码学中给出了计算不可区分的概念：
对于两个序列$E=\{e_1, e_2, \dots, e_n\}, E' = \{e'_1, e'_2, \dots, e'_n\}$，$a=\{a_1, a_2, \dots, a_n\}$为由$E$或$E'$生成的序列。$D$是一个在$2^k$时间内终止的概率算法，输出为0或1。$D(a, E) = 1$代表$a$由$E$产生，同理$D(a, E')=1$代表$a$由$E'$产生。当满足下式时，我们称$E, E'$为计算不可区分$(E \thickapprox E')$：
\begin{center}
    $\forall c \in N, \exists k_0 \in N, k > k_0, |Pr(D(a, E)=1) - Pr(D(a, E')=1)| < k^{-c}$
\end{center}

然而仅仅基于模拟证明的协议安全往往不够，这是因为此时只考虑到了协议独立运行的场景。而在实际中协议往往作为一个子模块与其他协议协作工作。因此Canetti提出了通用可复合安全（UC安全）用于证明组合协议安全性\cite{959888}。接下来我们将详细介绍UC安全框架，其主要基于交互式图灵机（ITM）定义协议实体，并由三个模型组合而成。

\paragraph{ITM}
ITM\cite{959888}作为一种抽象数学模型，通过纸带的方式完成与其他ITM的交互，从而将计算机的运行模式和交互接口形象化。它主要具有以下纸带：
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parsep}{0pt}
    \setlength{\parskip}{0pt}
    \item 身份带：只读，用于标识其为ITM
    \item 后门带：只读，用于理论上表示敌手对ITM的入侵
    \item 输入带和输出带：只读，ITM内部输入输出
    \item 输出通信带：可写，ITM对外通信输出
    \item 状态带：0/1状态，标记ITM是否处于激活态
\end{itemize}
\paragraph{真实环境模型}
该模型用于描述协议在真实环境中的工作方式，其中ITM实现实体包括：参与方$p_1, p_2, \dots , p_n$，敌手$A$和环境机$Z$。所有参与方都诚实按照协议$\gamma$逻辑进行直接交互，敌手A可以入侵参与方从而获取其内部状态与历史交互信息。$Z$在一开始被激活并开始写其他ITM的通信带从而激活这些ITM实体。当参与方实体尝试向其他实体发送信息却没有目标方时，将把信息写在$Z$的输出纸带上。对于随机信息$r=r_Z, r_A, r_1, \dots, r_n$，当$r$均匀分布时，我们用$REAL_{\gamma, A, Z}(k, z)$表示$Z$的输出。
\paragraph{理想过程模型}
此模型描述了协议执行的理想状态，主要ITM实体为：虚拟参与方$p_1, p_2, \dots , p_n$，模拟敌手$S$，环境机$Z$和理想函数$\digamma$。与真实环境不同，在理想环境中参与方没有执行程序的能力，不能直接交互，在收到消息后只能传递给理想函数。而模拟敌手的能力与真实敌手相同。同样对于随机信息$r=r_Z, r_A, r_1, \dots, r_n$，当$r$均匀分布时，我们用$IDEAL_{\digamma, S, Z}(k, z)$表示$Z$的输出。
\paragraph{混合模型}
当模型中同时包含运行协议$\gamma$的参与方$p_1, p_2, \dots , p_n$和理想函数$G$的多个副本时，我们将其称之为$G-$混合模型。此时$G$的多个副本之间不传送消息。我们令$HYB^G_{\gamma, A, Z}(k, z)$表示$Z$的输出。
\paragraph{UC安全实现与组合理论}
基于上述模型，我们可以方便地给出协议孤立安全的实现定义和混合模型下的安全实现定义。首先我们先给出孤立协议的安全实现定义，其主要基于真实环境模型和理想过程模型：对于任意$A$都存在$S$使得$REAL_{\gamma, A, Z}(k, z) \thickapprox IDEAL_{\digamma, S, Z}(k, z)$。即不存在$Z$以不可忽略概率区分其在与真实环境模型中交互还是在理想环境中。

将该定义延伸至混合模型上，我们可以得到定义$G-$混合模型下$\gamma$安全实现$\digamma$为：对于任意混合模型敌手$A$都存在理想环境中的模拟敌手$S$使得$HYB^G_{\gamma, A, Z}(k, z) \thickapprox IDEAL_{\digamma, S, Z}(k, z)$。

基于上述定义，可以得到UC组合定理：对于理想函数$\digamma, G$，在$G-$混合模型下协议$\gamma$安全实现$\digamma$，且协议$\varphi$安全实现$G$，则协议$\gamma^\varphi$安全实现$G$。
\section{基于zk-SNARKs的计算框架}
在2.1节中，我们在对比各类链下计算方案后认为基于zk-SNARKs的可验证计算是一种较优的解决思路。因此为进一步了解zk-SNARKs在区块链研究工作中的研究进展，本节将针对基于zk-SNARKs的计算框架作深入介绍。我们主要从现有的区块链应用，相关计算协议和链下计算架构三个模块作系统化论述。
\subsection{基于zk-SNARKs的区块链应用}
当前已有许多工作通过使用zk-SNARKs技术来构建区块链应用，本小节将对其作系统化的介绍。加密货币是区块链应用的一个主要方向，因此人们在这一领域首先进行了大胆的尝试。Zerocash\cite{6956581}对Zerocoin协议\cite{6547123}进行改进，采用了zk-SNARKs来实现匿名转账功能，基于该方案可以对转账的收付款方和转账金额都作隐藏。后续在2016年基于前述工作创建了加密货币Zcash\cite{Zcash}。此外混币服务也由于需要极强的隐私保护性而将zk-SNARKs技术作为其改进的一个方向。文献\cite{2020arXiv201001056L}介绍了无需依赖第三方或其他服务器的基于zk-SNARKs的混币协议。

除了针对隐私保护外，zk-SNARKs还被应用于区块链的扩展上，其核心思想为将链上的交易打包处理移到链下并将这一过程使用证明的方式作正确性保证。由于这一方向并不是本文探讨的主要问题，在此不做过多展开，其相关应用包括如ZK-Rollups\cite{zkrollups}和Coda\cite{cryptoeprint:2020/352}。
\subsection{基于zk-SNARKs的协同计算协议}
2016年Kosba提出Hawk\cite{7546538}协议用于解决智能合约的隐私保护问题。其将合约执行逻辑划分为链上部分和链下部分。链下计算被放在代理人节点上进行，而用户将与代理人节点进行直接交互。整个计算被分为几个步骤完成：首先用户提交zk-SNARKs证明和押金给链上合约发起一次交易，从而保证自己将加密的正确隐私数据传递给代理人节点。随后代理人节点负责接收多方用户提供的隐私数据，并在链下完成计算。在链下计算完成后代理人节点向链上提交自己的计算结果和计算证明，并由链上合约完成匿名转账。可以看到在这一框架中代理人节点成为了半个可信第三方的角色，即用户虽然无需信任该节点的计算正确性却必须相信后者不会泄露收到的隐私数据。此外这一框架与隐私匿名转账紧密结合，导致应用受限。

Zkay\cite{2020arXiv200901020B}给出了一种新的解决思路，即将标准solidity智能合约中的隐私变量作自动化的转译，从而构建于链下计算的关系。隐私数据在链上被加密存储，并在需要使用的地方基于ZoKrates\cite{8726497}工具库生成zk-SNARKs证明原语代替。这一思路虽然放弃了匿名性但是提供了对合约开发者较为友好的隐私保护方案。此后ZeeStar\cite{9833732}对这一工作作了进一步优化，通过同态加密将外部加密数据也应用于一笔交易计算中。但是这一方案仍存在的问题是其对外暴露了隐私变量的内存读取地址，这极大减弱了隐私保护性。

ZEXE\cite{9152634}受Zerocash\cite{6956581}的启发，为智能合约提供了更强的隐私保护特性，其对数据、身份和计算都作了隐藏。其核心思想是放弃跟踪交易的状态，而是通过记录的方式来验证交易的正确性。在这个过程中zk-SNARKs证明用于生成链下计算对记录的检查过程。在创建记录时，ZEXE首先通过predict来构建记录的开始状态与结束状态，这样链下计算即可检查记录是否满足前后状态的变更。然而这一方案使得原生的合约很难转变到以记录和谓词为核心的自定义编程模型中。
\subsection{基于zk-SNARKs的链下计算编译}
本小节我们主要介绍基于zk-SNARKs实现的链下计算编译模块。实际上计算程序往往不能直接用于zk-SNARKs算法，这是因为算法所需语言一般基于合适的NP描述，一个通用的表示是R1CS可满足问题\cite{10.1007/978-3-030-56877-1_25}。对此编译模块主要负责将开发者编写的计算程序转换为zk-SNARKs算法所需输入格式。接下来我们首先对算术电路和R1CS表示形式作简要介绍，随后介绍现有的编译实现。

\paragraph{算术电路和R1CS表示形式} 算术电路可用于表示有限域上加法和乘法，一个算术电路由多个加法门和乘法门组成。每个门都有输入和输出引脚，各个门的引脚相互连接从而构成一个完整的电路。电路的运行需要信号，我们将程序的外部输入定义为电路的外部信号，每个门的输出为内部信号。在zk-SANRKs中主要使用二输入电路，电路规模可以使用门的数量来表示。为便于描述，我们将电路作拍平，从而得到一阶约束系统R1CS。顾名思义，R1CS由一阶约束R1C组成，一个R1C对应电路中的一个逻辑门。为同时可以表示加法门和乘法门，R1C的完整形式为$\vec{a} \cdot \vec{s} \times \vec{b} \cdot \vec{s} = \vec{c} \cdot \vec{s}$，其中向量$\vec{s}$代表电路中所有信号，向量$\vec{a}, \vec{b}, \vec{c}$为其系数向量，取值只有0/1。

\paragraph{相关工作} 目前已有一些相关的工作对此进行了实现，但是他们所规定的源程序语言各不相同。Pinocchio\cite{10.1145/2856449}，ZoKrates\cite{8726497}，XJsnark\cite{8418647}等分别提供了将C语言代码，类Java代码和DSL转化为算术电路或R1CS的编译功能。与上述工作不同，一些库\cite{libsnark, zexe}使用电路描述语言作为编译的输入。这样的方式虽然要求链下合约开发者具备一定的语言基础，但是可以提高编译的效率同时低级语言可以显式的声明约束减少因编程失误造成的证明漏洞。其中Circom\cite{circom}使用JS和C共同实现，其定义了一套完整的电路语法用于描述链下计算，同时提供了一个丰富的密码学方法库从而使得开发者可以减少重复的开发工作。因此本文在编译模块的实现也采用Circom的语法，并对其性能进行了进一步优化，我们将在第五章给出具体内容。
